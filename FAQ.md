## FAQ

* [Поддерживает ли ripgrep файлы конфигурации?](#config)
* [Что изменилось в ripgrep недавно?](#changelog)
* [Когда следующий релиз?](#release)
* [Есть ли у ripgrep страница руководства man?](#manpage)
* [Поддерживает ли ripgrep автодополнение оболочки?](#complete)
* [Как получить результаты в согласованном порядке?](#order)
* [Как искать файлы, которые не являются UTF-8?](#encoding)
* [Как искать сжатые файлы?](#compressed)
* [Как искать по нескольким строкам?](#multiline)
* [Как использовать просмотр окружения и/или обратные ссылки?](#fancy)
* [Как настроить цвета ripgrep?](#colors)
* [Как включить настоящие цвета в Windows?](#truecolors-windows)
* [Как остановить ripgrep от порчи цветов при его завершении?](#stop-ripgrep)
* [Почему использование ведущего `/` в Windows не работает?](#because-cygwin)
* [Как обойти ограничение размера регулярного выражения?](#size-limit)
* [Как сделать флаг `-f/--file` быстрее?](#dfa-size)
* [Как сделать вывод похожим на вывод The Silver Searcher?](#silver-searcher-output)
* [Почему ripgrep становится медленнее, когда я включаю регулярные выражения PCRE2?](#pcre2-slow)
* [Когда я запускаю `rg`, почему выполняется какая-то другая команда?](#rg-other-cmd)
* [Как создать псевдоним для ripgrep в Windows?](#rg-alias-windows)
* [Как создать профиль PowerShell?](#powershell-profile)
* [Как передавать контент не-ASCII в ripgrep в Windows?](#pipe-non-ascii-windows)
* [Как искать и заменять с помощью ripgrep?](#search-and-replace)
* [Как лицензирован ripgrep?](#license)
* [Может ли ripgrep заменить grep?](#posix4ever)
* [Что означает "rip" в ripgrep?](#intentcountsforsomething)
* [Как я могу сделать пожертвование ripgrep или его сопровождающим?](#donations)


<h3 name="config">
Поддерживает ли ripgrep файлы конфигурации?
</h3>

Да. Смотрите [раздел руководства о файлах конфигурации](GUIDE.md#configuration-file).


<h3 name="changelog">
Что изменилось в ripgrep недавно?
</h3>

Пожалуйста, обратитесь к [CHANGELOG](CHANGELOG.md) ripgrep.


<h3 name="release">
Когда следующий релиз?
</h3>

ripgrep — это проект, участники которого являются волонтерами. График релизов
создает чрезмерное давление на этих волонтеров. Поэтому релизы выпускаются
на основе лучших усилий, и никакие даты **никогда не будут даны**.

Исключением из этого *могут быть* ошибки с высоким воздействием. Если релиз
ripgrep содержит значительный регресс, то обычно будет сильный толчок к выпуску
патч-релиза с исправлением. Однако никаких обещаний не дается.


<h3 name="manpage">
Есть ли у ripgrep страница руководства man?
</h3>

Да. Если вы установили ripgrep через менеджер пакетов в системе Unix, то она,
в идеале, была бы установлена для вас в надлежащем месте. В этом случае
`man rg` должна просто работать.

В противном случае вы можете попросить ripgrep сгенерировать страницу руководства:

```
$ mkdir -p man/man1
$ rg --generate man > man/man1/rg.1
$ MANPATH="$PWD/man" man rg
```

Или, если ваша версия `man` поддерживает флаг `-l/--local-file`, то этого будет
достаточно:

```
$ rg --generate man | man -l -
```

Обратите внимание, что документация опций страницы руководства эквивалентна выводу,
показанному в `rg --help`. Чтобы увидеть более сжатую документацию (одна строка на
флаг), запустите `rg -h`.

Страница руководства также включена во все
[бинарные релизы ripgrep](https://github.com/BurntSushi/ripgrep/releases).


<h3 name="complete">
Поддерживает ли ripgrep автодополнение оболочки?
</h3>

Да! Если вы установили ripgrep через менеджер пакетов в системе Unix, то файлы
автодополнения оболочки, включенные в архив релиза, должны были быть установлены
для вас автоматически. Если нет, вы можете сгенерировать автодополнение, используя
интерфейс командной строки ripgrep.

Для **bash**:

```
$ dir="$XDG_CONFIG_HOME/bash_completion"
$ mkdir -p "$dir"
$ rg --generate complete-bash > "$dir/rg.bash"
```

Для **fish**:

```
$ dir="$XDG_CONFIG_HOME/fish/completions"
$ mkdir -p "$dir"
$ rg --generate complete-fish > "$dir/rg.fish"
```

Для **zsh**, рекомендуемый подход:

```zsh
$ dir="$HOME/.zsh-complete"
$ mkdir -p "$dir"
$ rg --generate complete-zsh > "$dir/_rg"
```

А затем добавьте `$HOME/.zsh-complete` в ваш `fpath`, например, в вашем файле
`$HOME/.zshrc`:

```zsh
fpath=($HOME/.zsh-complete $fpath)
```

Или, если вы предпочитаете загружать и генерировать автодополнение одновременно,
вы можете добавить следующее в ваш файл `$HOME/.zshrc`:

```zsh
$ source <(rg --generate complete-zsh)
```

Обратите внимание, что хотя этот подход проще настроить, он обычно медленнее,
чем предыдущий метод, и добавит больше времени к загрузке вашей оболочки.

Для **PowerShell** создайте автодополнение:

```
$ rg --generate complete-powershell > _rg.ps1
```

А затем добавьте `. _rg.ps1` в ваш
[профиль PowerShell](https://technet.microsoft.com/en-us/library/bb613488(v=vs.85).aspx)
(обратите внимание на ведущую точку). Если файл `_rg.ps1` не находится в вашем `PATH`,
используйте `. /path/to/_rg.ps1` вместо этого.


<h3 name="order">
Как получить результаты в согласованном порядке?
</h3>

По умолчанию ripgrep использует параллелизм для выполнения поиска, потому что это
делает поиск намного быстрее на большинстве современных систем. Это, в свою очередь,
означает, что ripgrep имеет недетерминированный аспект, поскольку переплетение потоков
во время выполнения программы само по себе недетерминировано. Это имеет эффект печати
результатов в несколько произвольном порядке, и этот порядок может меняться от запуска
к запуску ripgrep.

Единственный способ сделать порядок результатов согласованным — попросить ripgrep
отсортировать вывод. В настоящее время это отключит весь параллелизм. (В меньших
репозиториях вы можете не заметить большой разницы в производительности!) Вы можете
добиться этого с помощью флага `--sort path`.

Здесь есть больше обсуждений на эту тему:
https://github.com/BurntSushi/ripgrep/issues/152


<h3 name="encoding">
Как искать файлы, которые не являются UTF-8?
</h3>

Смотрите [раздел руководства о кодировке файлов](GUIDE.md#file-encoding).


<h3 name="compressed">
Как искать сжатые файлы?
</h3>

Флаг `-z/--search-zip` ripgrep заставит его автоматически искать сжатые файлы.
В настоящее время это поддерживает gzip, bzip2, xz, lzma, lz4, Brotli и Zstd.
Каждый из них требует, чтобы соответствующие бинарные файлы `gzip`, `bzip2`, `xz`,
`lz4`, `brotli` и `zstd` были установлены в вашей системе. (То есть, ripgrep
выполняет декомпрессию, вызывая другой процесс.)

ripgrep в настоящее время не ищет архивные форматы, поэтому файлы `*.tar.gz`,
например, пропускаются.


<h3 name="multiline">
Как искать по нескольким строкам?
</h3>

Флаг `-U/--multiline` позволяет ripgrep сообщать результаты, которые охватывают
несколько строк.


<h3 name="fancy">
Как использовать просмотр окружения и/или обратные ссылки?
</h3>

Движок регулярных выражений ripgrep по умолчанию не поддерживает просмотр окружения
или обратные ссылки. Это в первую очередь потому, что движок по умолчанию реализован
с использованием конечных автоматов, чтобы гарантировать линейную сложность времени
худшего случая на всех входах. Обратные ссылки невозможно реализовать в этой парадигме,
и просмотр окружения, похоже, трудно сделать эффективно.

Однако ripgrep опционально поддерживает использование PCRE2 в качестве движка регулярных
выражений вместо движка по умолчанию на основе конечных автоматов. Вы можете включить
PCRE2 с помощью флага `-P/--pcre2`. Например, в корне репозитория ripgrep вы можете
легко найти все палиндромы:

```
$ rg -P '(\w{10})\1'
tests/misc.rs
483:    cmd.arg("--max-filesize").arg("44444444444444444444");
globset/src/glob.rs
1206:    matches!(match7, "a*a*a*a*a*a*a*a*a", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");
```

Если ваша версия ripgrep не поддерживает PCRE2, то вы получите сообщение об ошибке,
когда попытаетесь использовать флаг `-P/--pcre2`:

```
$ rg -P '(\w{10})\1'
PCRE2 is not available in this build of ripgrep
```

Большинство релизов, распространяемых проектом ripgrep здесь на GitHub, будут
поставляться с включенным PCRE2. Если вы установили ripgrep другими средствами
(например, через менеджер пакетов вашей системы), то, пожалуйста, обратитесь к
сопровождающему этого пакета, чтобы узнать, можно ли включить функцию PCRE2.


<h3 name="colors">
Как настроить цвета ripgrep?
</h3>

ripgrep имеет два флага, связанных с цветами:

* `--color` управляет *когда* использовать цвета.
* `--colors` управляет *какие* цвета использовать.

Флаг `--color` принимает одно из следующих возможных значений: `never`, `auto`,
`always` или `ansi`. Значение `auto` является значением по умолчанию и заставит
ripgrep включать цвета только при печати в терминал. Но если вы передадите ripgrep
в файл или какой-либо другой процесс, то он подавит цвета.

Флаг `--colors` немного сложнее. Общий формат:

```
--colors '{type}:{attribute}:{value}'
```

* `{type}` должен быть одним из `path`, `line`, `column` или `match`. Каждый из них
  соответствует четырем различным вещам, к которым ripgrep добавит цвет в своем выводе.
  Выберите тип, цвет которого вы хотите изменить.
* `{attribute}` должен быть одним из `fg`, `bg` или `style`, соответствуя цвету переднего
  плана, цвету фона или различным стилям (например, следует ли делать вывод жирным или нет).
* `{value}` определяется значением `{attribute}`. Если `{attribute}` — `style`, то `{value}`
  должен быть одним из `nobold`, `bold`, `nointense`, `intense`, `nounderline`, `underline`,
  `noitalic` или `italic`. Если `{attribute}` — `fg` или `bg`, то `{value}` должен быть цветом.

Цвет указывается одним из восьми английских названий, одним 256-битным числом или RGB тройкой
(с более чем 16 миллионами возможных значений, или "настоящий цвет").

Названия цветов: `red`, `blue`, `green`, `cyan`, `magenta`, `yellow`, `white` или `black`.

Одно 256-битное число — это значение в диапазоне 0-255 (включительно). Оно может быть в
десятичном формате (например, `62`) или шестнадцатеричном формате (например, `0x3E`).

RGB тройка соответствует трем числам (десятичным или шестнадцатеричным), разделенным запятыми.

В качестве особого случая, `--colors '{type}:none'` очистит все цвета и стили, связанные с
`{type}`, что позволит вам начать с чистого листа (вместо того, чтобы строить поверх настроек
цветов ripgrep по умолчанию).

Вот пример, который выделяет совпадения приятным синим фоном с жирным белым текстом:

```
$ rg somepattern \
    --colors 'match:none' \
    --colors 'match:bg:0x33,0x66,0xFF' \
    --colors 'match:fg:white' \
    --colors 'match:style:bold'
```

Цвета являются идеальным кандидатом для установки в вашем
[файле конфигурации](GUIDE.md#configuration-file). Смотрите [вопрос об эмуляции стиля вывода
The Silver Searcher](#silver-searcher-output) для примера, специфичного для цветов.


<h3 name="truecolors-windows">
Как включить настоящие цвета в Windows?
</h3>

Во-первых, смотрите [ответ предыдущего вопроса о настройке цветов](#colors).

Во-вторых, раскраска в Windows немного сложна. Если вы используете терминал вроде Cygwin,
то, вероятно, поддержка настоящих цветов уже работает из коробки. Однако, если вы используете
обычную консоль Windows (`cmd` или `PowerShell`) и версию Windows до 10, то нет известного
способа получить поддержку настоящих цветов. Если вы находитесь на Windows 10 и используете
консоль Windows, то настоящие цвета должны работать из коробки с одной оговоркой: вам может
потребоваться сначала очистить настройки цветов ripgrep по умолчанию. То есть, вместо этого:

```
$ rg somepattern --colors 'match:fg:0x33,0x66,0xFF'
```

вы должны сделать это

```
$ rg somepattern --colors 'match:none' --colors 'match:fg:0x33,0x66,0xFF'
```

Это потому, что ripgrep может установить стиль по умолчанию для `match` в `bold`, и, похоже,
поддержка VT100 Windows 10 не позволяет одновременно использовать жирные и настоящие цвета
ANSI escape. Приведенный выше обходной путь очистит стиль ripgrep по умолчанию, позволяя вам
создать его точно так, как вы хотите.


<h3 name="stop-ripgrep">
Как остановить ripgrep от порчи цветов при его завершении?
</h3>

Введите `color` в cmd.exe (Command Prompt) и `echo -ne "\033[0m"` в Unix-подобных системах,
чтобы восстановить ваш исходный цвет переднего плана.

В PowerShell вы можете добавить следующий код в ваш профиль, который восстановит исходный
цвет переднего плана при вызове `Reset-ForegroundColor`. Включение строки `Set-Alias` позволит
вам вызывать его просто как `color`.

```powershell
$OrigFgColor = $Host.UI.RawUI.ForegroundColor
function Reset-ForegroundColor {
	$Host.UI.RawUI.ForegroundColor = $OrigFgColor
}
Set-Alias -Name color -Value Reset-ForegroundColor
```

PR [#187](https://github.com/BurntSushi/ripgrep/pull/187) исправил это, и это позже было
удалено в [#281](https://github.com/BurntSushi/ripgrep/issues/281). Полное объяснение доступно
[здесь](https://github.com/BurntSushi/ripgrep/issues/281#issuecomment-269093893).


<h3 name="because-cygwin">
Почему использование ведущего `/` в Windows не работает?
</h3>

Если вы используете cygwin в Windows и пытаетесь искать шаблон, начинающийся с `/`, то
возможно, что cygwin искажает этот шаблон без вашего ведома. Например, если вы попытались
запустить `rg /foo` в оболочке cygwin в Windows, то cygwin может ошибочно выполнить
преобразование пути для `/foo`, что приведет к тому, что вместо этого будет искаться
`rg C:/msys64/foo`.

Вы можете исправить это одним из трех способов:

1. Прекратите использовать cygwin.
2. Экранируйте ведущий слэш дополнительным слэшем. Например, `rg //foo`.
3. Временно отключите преобразование пути, установив `MSYS_NO_PATHCONV=1`. Например,
   `MSYS_NO_PATHCONV=1 rg /foo`.

Для получения более подробной информации смотрите https://github.com/BurntSushi/ripgrep/issues/1277


<h3 name="size-limit">
Как обойти ограничение размера регулярного выражения?
</h3>

Если вы дали ripgrep особенно большой шаблон (или большое количество меньших шаблонов),
то возможно, что он не сможет скомпилироваться, потому что достиг предустановленного
лимит. Например:

```
$ rg '\pL{1000}'
Compiled regex exceeds size limit of 10485760 bytes.
```

(Примечание: `\pL{1000}` может выглядеть маленьким, но `\pL` — это класс символов,
содержащий все буквы Unicode, который довольно велик. *И* он повторяется 1000 раз.)

В этом случае вы можете обойти это, просто увеличив лимит:

```
$ rg '\pL{1000}' --regex-size-limit 1G
```

Увеличение лимита до 1 ГБ не обязательно означает, что ripgrep будет использовать так
много памяти. Лимит просто говорит, что ему разрешено (приблизительно) использовать
так много памяти для построения регулярного выражения.


<h3 name="dfa-size">
Как сделать флаг <code>-f/--file</code> быстрее?
</h3>

Флаг `-f/--file` позволяет передать ripgrep файл, который содержит шаблон на каждой
строке. ripgrep затем сообщит любую строку, которая соответствует любому из шаблонов.

Если этот файл шаблонов станет слишком большим, то возможно, ripgrep значительно
замедлится. *Обычно* это происходит потому, что внутренний кэш слишком мал и заставит
ripgrep перейти к более медленному, но более надежному движку регулярных выражений.
Если это действительно проблема, то можно увеличить этот кэш и вернуть скорость. Кэш
можно контролировать с помощью флага `--dfa-size-limit`. Например, использование
`--dfa-size-limit 1G` установит размер кэша в 1 ГБ. (Обратите внимание, что это не
означает, что ripgrep будет автоматически использовать 1 ГБ памяти, но это позволит
движку регулярных выражений, если ему нужно.)


<h3 name="silver-searcher-output">
Как сделать вывод похожим на вывод The Silver Searcher?
</h3>

Используйте флаг `--colors`, например:

```
rg --colors line:fg:yellow      \
   --colors line:style:bold     \
   --colors path:fg:green       \
   --colors path:style:bold     \
   --colors match:fg:black      \
   --colors match:bg:yellow     \
   --colors match:style:nobold  \
   foo
```

В качестве альтернативы, добавьте вашу конфигурацию цветов в файл конфигурации ripgrep
(который активируется установкой переменной окружения `RIPGREP_CONFIG_PATH`, указывающей
на ваш файл конфигурации). Например:

```
$ cat $HOME/.config/ripgrep/rc
--colors=line:fg:yellow
--colors=line:style:bold
--colors=path:fg:green
--colors=path:style:bold
--colors=match:fg:black
--colors=match:bg:yellow
--colors=match:style:nobold
$ RIPGREP_CONFIG_PATH=$HOME/.config/ripgrep/rc rg foo
```


<h3 name="pcre2-slow">
Почему ripgrep становится медленнее, когда я включаю регулярные выражения PCRE2?
</h3>

Когда вы используете флаг `--pcre2` (`-P` для краткости), ripgrep будет использовать
движок регулярных выражений PCRE2 вместо движка по умолчанию. Оба движка регулярных
выражений довольно быстры, но PCRE2 предоставляет ряд дополнительных функций, таких
как просмотр окружения и обратные ссылки, которые многим нравятся. Это в значительной
степени связано с тем, что PCRE2 использует реализацию с возвратом, тогда как движок
по умолчанию использует реализацию на основе конечного автомата. Первая предоставляет
возможность добавить множество наворотов по сравнению со второй, но вторая выполняется
со сложностью линейного времени в худшем случае.

С этим покончено, если вы использовали `-P` с ripgrep, вы могли заметить, что он может
быть медленнее. Причины, по которым это происходит, довольно сложны, и они сложны, потому
что оптимизации, которые ripgrep использует для реализации быстрого поиска, сложны.

Задача, стоящая перед ripgrep, несколько проста; все, что ему нужно сделать, — это искать
в файле вхождения некоторого шаблона, а затем печатать строки, содержащие эти вхождения.
Проблема заключается в том, что считается допустимым совпадением и как именно мы читаем
байты из файла.

С точки зрения того, что считается допустимым совпадением, помните, что ripgrep по умолчанию
будет сообщать только о совпадениях, охватывающих одну строку. Проблема здесь в том, что
некоторые шаблоны могут совпадать по нескольким строкам, и ripgrep должен предотвратить это.
Например, `foo\sbar` будет соответствовать `foo\nbar`. Самый очевидный способ добиться этого —
прочитать данные из файла, а затем применить поиск шаблона к этим данным для каждой строки.
Проблема с этим подходом в том, что он может быть довольно медленным; было бы намного быстрее
позволить поиску шаблона охватить как можно больше данных. Это быстрее, потому что это избавляет
от накладных расходов на поиск границ каждой строки, а также потому, что это избавляет от
накладных расходов на запуск и остановку поиска шаблона для каждой отдельной строки. (Это
работает в рамках общего предположения, что совпадающие строки гораздо реже, чем несовпадающие
строки.)

Оказывается, мы можем использовать более быстрый подход, применив очень простое ограничение к
шаблону: *статически предотвратить* совпадение шаблона через символ `\n`. А именно, получив
шаблон вроде `foo\sbar`, ripgrep автоматически удалит `\n` из класса символов `\s`. В некоторых
случаях простое удаление не так просто. Например, ripgrep вернет ошибку, когда ваш шаблон включает
литерал `\n`:

```
$ rg '\n'
the literal '"\n"' is not allowed in a regex
```

Так что это имеет отношение к PCRE2? Что ж, движок регулярных выражений ripgrep по умолчанию
предоставляет API для выполнения синтаксического анализа шаблона способом, который значительно
облегчает удаление `\n` из шаблона (или в противном случае обнаруживает его и сообщает об ошибке,
если удаление невозможно). PCRE2, похоже, не предоставляет подобного API, поэтому ripgrep не
выполняет никакого удаления, когда PCRE2 включен. Это заставляет ripgrep использовать "медленную"
стратегию поиска, ища каждую строку по отдельности.

Хорошо, так если включение PCRE2 замедляет метод поиска по умолчанию, потому что заставляет
совпадения ограничиваться одной строкой, то почему PCRE2 также иногда медленнее при выполнении
многострочного поиска? Что ж, это потому, что есть *несколько* причин, почему использование PCRE2
в ripgrep может быть медленнее, чем движок регулярных выражений по умолчанию. На этот раз вините
поддержку Unicode PCRE2, которую ripgrep включает по умолчанию. В частности, PCRE2 не может
одновременно включить поддержку Unicode и искать произвольные данные. То есть, когда поддержка
Unicode PCRE2 включена, данные **должны** быть действительным UTF-8 (сделать иное — значит вызвать
неопределенное поведение). Это в отличие от движка регулярных выражений ripgrep по умолчанию,
который может включить поддержку Unicode и все еще искать произвольные данные. Движок регулярных
выражений ripgrep по умолчанию просто не будет соответствовать недопустимому UTF-8 для шаблона,
который в противном случае может соответствовать только действительному UTF-8. Почему PCRE2 не
делает то же самое? Этот автор не знаком с его внутренностями, поэтому мы не можем комментировать
это здесь.

Суть здесь в том, что мы не можем включить поддержку Unicode PCRE2 без одновременного наложения
штрафа за производительность для обеспечения того, что мы ищем действительный UTF-8. В частности,
ripgrep перекодирует содержимое каждого файла в UTF-8, заменяя недопустимые данные UTF-8 кодом
замены Unicode. ripgrep затем отключает собственную внутреннюю проверку UTF-8 PCRE2, поскольку мы
гарантировали, что данные, которые мы ему передадим, будут действительным UTF-8. Причина, по которой
ripgrep принимает этот подход, заключается в том, что если мы передадим PCRE2 недопустимый UTF-8,
то он сообщит об ошибке совпадения, если столкнется с недопустимой последовательностью UTF-8. Это
не хорошая новость для ripgrep, поскольку это остановит его от поиска остальной части файла, а также
напечатает потенциально нежелательные сообщения об ошибках пользователям.

Все хорошо, вышеизложенное — это много информации для проглатывания, если вы уже не знакомы с
внутренностями ripgrep. Давайте сделаем это конкретным с некоторыми примерами. Во-первых, давайте
получим данные, достаточно большие, чтобы усилить различия в производительности:

```
$ curl -O 'https://burntsushi.net/stuff/subtitles2016-sample.gz'
$ gzip -d subtitles2016-sample
$ md5sum subtitles2016-sample
e3cb796a20bbc602fbfd6bb43bda45f5   subtitles2016-sample
```

Для поиска этих данных мы будем использовать шаблон `^\w{42}$`, который содержит ровно одно
совпадение в файле и не имеет литералов. Отсутствие литералов важно, потому что это гарантирует,
что движок регулярных выражений не будет использовать оптимизации литералов для ускорения поиска.
Другими словами, это позволяет нам последовательно рассуждать о фактической задаче, которую выполняет
движок регулярных выражений.

Давайте теперь пройдемся по нескольким примерам в свете вышеизложенной информации. Во-первых, давайте
рассмотрим поиск по умолчанию, используя движок регулярных выражений ripgrep по умолчанию, а затем
тот же поиск с PCRE2:

```
$ time rg '^\w{42}$' subtitles2016-sample
21225780:EverymajordevelopmentinthehistoryofAmerica

real    0m1.783s
user    0m1.731s
sys     0m0.051s

$ time rg -P '^\w{42}$' subtitles2016-sample
21225780:EverymajordevelopmentinthehistoryofAmerica

real    0m2.458s
user    0m2.419s
sys     0m0.038s
```

В этом конкретном примере оба поиска шаблонов используют класс символов `\w`, осведомленный о Unicode,
и оба подсчитывают строки, чтобы сообщить номера строк. Ключевое различие здесь в том, что первый поиск
не будет искать построчно, но второй будет. Мы можем наблюдать, какую стратегию использует ripgrep,
передав флаг `--trace`:

```
$ rg '^\w{42}$' subtitles2016-sample --trace
[... вырезано ...]
TRACE|grep_searcher::searcher|grep-searcher/src/searcher/mod.rs:622: Some("subtitles2016-sample"): searching via memory map
TRACE|grep_searcher::searcher|grep-searcher/src/searcher/mod.rs:712: slice reader: searching via slice-by-line strategy
TRACE|grep_searcher::searcher::core|grep-searcher/src/searcher/core.rs:61: searcher core: will use fast line searcher
[... вырезано ...]

$ rg -P '^\w{42}$' subtitles2016-sample --trace
[... вырезано ...]
TRACE|grep_searcher::searcher|grep-searcher/src/searcher/mod.rs:622: Some("subtitles2016-sample"): searching via memory map
TRACE|grep_searcher::searcher|grep-searcher/src/searcher/mod.rs:705: slice reader: needs transcoding, using generic reader
TRACE|grep_searcher::searcher|grep-searcher/src/searcher/mod.rs:685: generic reader: searching via roll buffer strategy
TRACE|grep_searcher::searcher::core|grep-searcher/src/searcher/core.rs:63: searcher core: will use slow line searcher
[... вырезано ...]
```

Первый говорит, что он использует стратегию "быстрый поиск строки", тогда как последний говорит, что
он использует "медленный поиск строки". Последний также показывает, что мы декодируем содержимое файла,
что также влияет на производительность.

Интересно, что в этом случае шаблон не соответствует `\n`, и файл, который мы ищем, является действительным
UTF-8, поэтому ни стратегия медленного поиска построчно, ни декодирование не нужны. Мы могли бы исправить
первую проблему с лучшими API интроспекции PCRE2. Мы можем фактически исправить последнюю проблему с флагом
`--no-encoding` ripgrep, который предотвращает автоматическое декодирование UTF-8, но включит собственную
проверку действительности UTF-8 PCRE2. К сожалению, это медленнее в моей сборке ripgrep:

```
$ time rg -P '^\w{42}$' subtitles2016-sample --no-encoding
21225780:EverymajordevelopmentinthehistoryofAmerica

real    0m3.074s
user    0m3.021s
sys     0m0.051s
```

(Совет: используйте флаг `--trace`, чтобы проверить, что декодирование в ripgrep не происходит.)

Возможная причина, по которой проверка UTF-8 PCRE2 медленнее, заключается в том, что она может быть не лучше,
чем высокооптимизированные процедуры проверки UTF-8, найденные в библиотеке
[`encoding_rs`](https://github.com/hsivonen/encoding_rs), которую ripgrep использует для декодирования UTF-8.
Более того, моя сборка ripgrep включает оптимизации SIMD `encoding_rs`, которые могут быть задействованы здесь.

Также обратите внимание, что использование флага `--no-encoding` может привести к тому, что PCRE2 сообщит об
ошибках недопустимого UTF-8, что заставит ripgrep прекратить поиск файла:

```
$ cat invalid-utf8
foobar

$ xxd invalid-utf8
00000000: 666f 6fff 6261 720a                      foo.bar.

$ rg foo invalid-utf8
1:foobar

$ rg -P foo invalid-utf8
1:foobar

$ rg -P foo invalid-utf8 --no-encoding
invalid-utf8: PCRE2: error matching: UTF-8 error: illegal byte (0xfe or 0xff)
```

Хорошо, на этом этапе вы можете подумать, что мы можем исправить обе проблемы, включив многострочный поиск.
В конце концов, наш конкретный шаблон все равно не может совпадать по нескольким строкам, поэтому мы все еще
получим результаты, которые хотим. Давайте попробуем:

```
$ time rg -U '^\w{42}$' subtitles2016-sample
21225780:EverymajordevelopmentinthehistoryofAmerica

real    0m1.803s
user    0m1.748s
sys     0m0.054s

$ time rg -P -U '^\w{42}$' subtitles2016-sample
21225780:EverymajordevelopmentinthehistoryofAmerica

real    0m2.962s
user    0m2.246s
sys     0m0.713s
```

Время поиска остается прежним с движком регулярных выражений по умолчанию, но поиск PCRE2 становится *медленнее*.
Что произошло? Секреты могут быть раскрыты с флагом `--trace` еще раз. В первом случае ripgrep фактически
обнаруживает, что шаблон не может совпадать по нескольким строкам, и поэтому вернется к стратегии "быстрый
поиск строки", как с нашим поиском без `-U`.

Однако для PCRE2 все гораздо хуже. А именно, поскольку режим Unicode все еще включен, ripgrep все еще будет
декодировать UTF-8, чтобы гарантировать, что он передает только действительный UTF-8 в PCRE2. К сожалению,
один ключевой недостаток многострочного поиска заключается в том, что ripgrep не может делать это инкрементально.
Поскольку совпадения могут быть произвольно длинными, ripgrep фактически нуждается в том, чтобы весь файл был в
памяти сразу. Обычно мы можем использовать отображение памяти для этого, но поскольку нам нужно декодировать UTF-8
файла перед его поиском, ripgrep в конечном итоге читает все содержимое файла в кучу перед выполнением поиска. Ой.

Хорошо, так что Unicode убивает нас здесь. Файл, который мы ищем, *в основном* ASCII, поэтому, возможно, мы в
порядке с пропуском некоторых данных. (Попробуйте `rg '[\w--\p{ascii}]'`, чтобы увидеть не-ASCII словные символы,
которые класс символов `\w` только ASCII пропустит.) Мы можем отключить Unicode в обоих поисках, но это делается
по-разному в зависимости от используемого нами движка регулярных выражений:

```
$ time rg '(?-u)^\w{42}$' subtitles2016-sample
21225780:EverymajordevelopmentinthehistoryofAmerica

real    0m1.714s
user    0m1.669s
sys     0m0.044s

$ time rg -P '^\w{42}$' subtitles2016-sample --no-pcre2-unicode
21225780:EverymajordevelopmentinthehistoryofAmerica

real    0m1.997s
user    0m1.958s
sys     0m0.037s
```

По большей части движок регулярных выражений ripgrep по умолчанию работает примерно так же. PCRE2 немного улучшается
и теперь почти так же быстр, как движок по умолчанию. Если вы посмотрите на вывод `--trace`, вы увидите, что ripgrep
больше не будет выполнять декодирование UTF-8, но он все еще использует медленный поиск построчно.

На этом этапе мы можем объединить все наши знания выше: давайте попробуем уйти от медленного поиска построчно, включив
многострочный режим, и давайте прекратим декодирование UTF-8, отключив поддержку Unicode:

```
$ time rg -U '(?-u)^\w{42}$' subtitles2016-sample
21225780:EverymajordevelopmentinthehistoryofAmerica

real    0m1.714s
user    0m1.655s
sys     0m0.058s

$ time rg -P -U '^\w{42}$' subtitles2016-sample --no-pcre2-unicode
21225780:EverymajordevelopmentinthehistoryofAmerica

real    0m1.121s
user    0m1.071s
sys     0m0.048s
```

А, вот JIT PCRE2 сияет! Движок регулярных выражений ripgrep по умолчанию снова остается примерно таким же, но PCRE2
больше не нуждается в поиске построчно, и ему больше не нужно выполнять какие-либо проверки UTF-8. Это позволяет файлу
отображаться в память и передаваться прямо через JIT PCRE2 с впечатляющей скоростью. (Как краткая и интересная
историческая заметка, конфигурация "отображение памяти + многострочный + без-Unicode" — это именно конфигурация,
используемая The Silver Searcher. Этот анализ, возможно, проливает некоторое рассуждение на то, почему эта конфигурация
полезна!)

В заключение, если вы хотите, чтобы PCRE2 работал как можно быстрее, и вам не нужен Unicode, и вы не заботитесь о
совпадениях, возможно, охватывающих несколько строк, то включите многострочный режим с `-U` и отключите поддержку
Unicode PCRE2 с флагом `--no-pcre2-unicode`.

Caveat emptor: Этот автор не является экспертом PCRE2, поэтому могут быть API, которые могут улучшить производительность,
которые автор пропустил. Аналогично, могут быть альтернативные дизайны для инструмента поиска, которые более подходят
к тому, как работает PCRE2.


<h3 name="rg-other-cmd">
Когда я запускаю <code>rg</code>, почему выполняется какая-то другая команда?
</h3>

Вероятно, у вас есть псевдоним оболочки или даже другой инструмент с именем `rg`, который мешает ripgrep.
Запустите `which rg`, чтобы увидеть, что это.

(В частности, плагин Rails для [Oh My Zsh](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#rails)
устанавливает псевдоним `rg` для `rails generate`.)

Подобные проблемы можно решить одним из нескольких способов:

* Если вы используете плагин OMZ Rails, отключите его, отредактировав массив `plugins` в вашей конфигурации zsh.
* Временно обойдите существующий псевдоним `rg`, вызвав ripgrep как `command rg`, `\rg` или `'rg'`.
* Временно обойдите существующий псевдоним или другой инструмент с именем `rg`, вызвав ripgrep по его полному пути
  (например, `/usr/bin/rg` или `/usr/local/bin/rg`).
* Постоянно отключите существующий псевдоним `rg`, добавив `unalias rg` в конец вашего файла конфигурации оболочки
  (например, `.bash_profile` или `.zshrc`).
* Дайте ripgrep собственный псевдоним, который не конфликтует с другими инструментами/псевдонимами, добавив строку,
  подобную следующей, в конец вашего файла конфигурации оболочки: `alias ripgrep='command rg'`.


<h3 name="rg-alias-windows">
Как создать псевдоним для ripgrep в Windows?
</h3>

Часто вы можете почувствовать необходимость создать псевдоним для команд, которые вы используете часто, устанавливая
определенные флаги. Но псевдонимы функций PowerShell не ведут себя как ваш типичный псевдоним оболочки linux. Вам
всегда нужно распространять аргументы и ввод `stdin`. Но это нельзя сделать просто как
`function grep() { $input | rg.exe --hidden $args }`

Используйте приведенный ниже пример как ссылку на то, как настроить псевдоним в PowerShell.

```powershell
function grep {
    $count = @($input).Count
    $input.Reset()

    if ($count) {
        $input | rg.exe --hidden $args
    }
    else {
        rg.exe --hidden $args
    }
}
```

Специальные переменные PowerShell:

* input — это объект `stdin` PowerShell, который позволяет вам получить доступ к его содержимому.
* args — это массив аргументов, переданных этой функции.

Этот псевдоним проверяет, есть ли ввод `stdin`, и распространяет его только если есть некоторые строки.
В противном случае пустой `$input` заставит PowerShell запустить `rg` для поиска пустого `stdin`.


<h3 name="powershell-profile">
Как создать профиль PowerShell?
</h3>

Для настройки PowerShell при запуске есть специальный скрипт PowerShell, который должен быть создан.
Чтобы найти его расположение, введите `$profile`. Смотрите
[документацию Microsoft](https://technet.microsoft.com/en-us/library/bb613488(v=vs.85).aspx)
для получения более подробной информации.

Любой код PowerShell в этом файле оценивается в начале консоли. Таким образом, вы можете иметь собственные
псевдонимы, созданные при запуске.


<h3 name="pipe-non-ascii-windows">
Как передавать контент не-ASCII в ripgrep в Windows?
</h3>

При передаче ввода в собственные исполняемые файлы в PowerShell кодировка ввода контролируется переменной
`$OutputEncoding`. По умолчанию она установлена в US-ASCII, и любые символы в конвейере, которые не имеют
кодировок в US-ASCII, преобразуются в символы `?` (вопросительный знак).

Чтобы изменить эту настройку, установите `$OutputEncoding` в другую кодировку, представленную объектом
кодировки .NET. Некоторые распространенные примеры приведены ниже. Значение этой переменной сбрасывается
при перезапуске PowerShell, поэтому, чтобы эта настройка вступила в силу каждый раз при запуске PowerShell,
добавьте строку, устанавливающую переменную, в ваш профиль PowerShell.

Примеры настроек `$OutputEncoding`:

* UTF-8 без BOM: `$OutputEncoding = [System.Text.UTF8Encoding]::new()`
* Кодировка вывода консоли: `$OutputEncoding = [System.Console]::OutputEncoding`

Если у вас все еще есть проблемы с кодировкой, вы также можете принудительно установить кодировку, которую
консоль будет использовать для печати, в UTF-8 с помощью `[System.Console]::OutputEncoding = [System.Text.Encoding]::UTF8`.
Это также будет сброшено при перезапуске PowerShell, поэтому вы также можете добавить эту строку в ваш профиль,
если хотите сделать настройку постоянной.

<h3 name="search-and-replace">
Как искать и заменять с помощью ripgrep?
</h3>

Используя только ripgrep, вы не можете. ripgrep — это инструмент поиска, который никогда не касается ваших
файлов. Однако вывод ripgrep можно передавать в другие инструменты, которые модифицируют файлы на диске.
Смотрите [этот issue](https://github.com/BurntSushi/ripgrep/issues/74) для получения более подробной информации.

sed — это один из таких инструментов, который может модифицировать файлы на диске. sed может принимать имя
файла и команду подстановки для поиска и замены в указанном файле. Файлы, содержащие совпадающие шаблоны,
могут быть предоставлены sed с помощью

```
rg foo --files-with-matches
```

Вывод этой команды — это список имен файлов, которые содержат совпадение для шаблона `foo`.

Этот список можно передать в `xargs`, который разделит имена файлов из стандартного ввода на аргументы для
команды, следующей за xargs. Вы можете использовать эту комбинацию, чтобы передать список имен файлов в sed
для замены. Например:

```
rg foo --files-with-matches | xargs sed -i 's/foo/bar/g'
```

заменит все экземпляры 'foo' на 'bar' в файлах, в которых ripgrep находит шаблон foo. Флаг `-i` для sed
указывает, что вы редактируете файлы на месте, а `s/foo/bar/g` говорит, что вы выполняете **s**ubstitution
(подстановку) шаблона `foo` на `bar`, и что вы делаете эту подстановку **g**lobally (все вхождения шаблона
в каждом файле).

Примечание: приведенная выше команда предполагает, что вы используете GNU sed. Если вы используете BSD sed
(по умолчанию на macOS и FreeBSD), то вы должны изменить приведенную выше команду на следующую:

```
rg foo --files-with-matches | xargs sed -i '' 's/foo/bar/g'
```

Флаг `-i` в BSD sed требует, чтобы расширение файла было дано для создания резервных копий всех измененных
файлов. Указание пустой строки предотвращает создание резервных копий файлов.

Наконец, если какие-либо из ваших путей к файлам содержат пробелы в них, то вам может потребоваться
разделить ваши пути к файлам терминатором NUL. Это требует указания ripgrep выводить байты NUL между каждым
путем и указания xargs читать пути, разделенные байтами NUL:

```
rg foo --files-with-matches -0 | xargs -0 sed -i 's/foo/bar/g'
```

Чтобы узнать больше о sed, смотрите руководство sed [здесь](https://www.gnu.org/software/sed/manual/sed.html).

Кроме того, у Facebook есть инструмент под названием [fastmod](https://github.com/facebookincubator/fastmod),
который использует некоторые из тех же библиотек, что и ripgrep, и может предоставить более эргономичный опыт
поиска и замены.


<h3 name="license">
Как лицензирован ripgrep?
</h3>

ripgrep имеет двойную лицензию под лицензиями [Unlicense](https://unlicense.org/) и MIT. В частности, вы
можете использовать ripgrep в соответствии с условиями любой лицензии.

Причина, по которой ripgrep имеет двойную лицензию таким образом, двояка:

1. Я, как автор ripgrep, хотел бы участвовать в небольшом акте идеологического активизма, продвигая цель
   Unlicense: отказаться от интереса к монополии на авторские права.
2. Я, как автор ripgrep, хотел бы, чтобы как можно больше людей использовали ripgrep. Поскольку Unlicense
   не является доказанной или хорошо известной лицензией, ripgrep также предлагается под лицензией MIT,
   которая распространена и принята почти всеми.

Более конкретно, ripgrep и все его зависимости совместимы с этим выбором лицензирования. В частности,
зависимости ripgrep (прямые и транзитивные) всегда будут ограничиваться разрешительными лицензиями. То есть,
ripgrep никогда не будет зависеть от кода, который не лицензирован разрешительно. Это означает отклонение
любой зависимости, которая использует лицензию copyleft, такую как GPL, LGPL, MPL или любые лицензии Creative
Commons ShareAlike. Независимо от того, является ли лицензия "слабой" copyleft или нет; ripgrep **не** будет
зависеть от нее.


<h3 name="posix4ever">
Может ли ripgrep заменить grep?
</h3>

Да и нет.

Если, услышав, что "ripgrep может заменить grep," вы *на самом деле* слышите, "ripgrep может использоваться
в каждом экземпляре, где может использоваться grep, точно так же, для тех же случаев использования, с точно
таким же поведением ошибка-за-ошибку," то нет, ripgrep тривиально *не может* заменить grep. Более того,
ripgrep *никогда* не заменит grep.

Если, услышав, что "ripgrep может заменить grep," вы *на самом деле* слышите, "ripgrep может заменить grep
в некоторых случаях, а не в других случаях использования," то да, это действительно так!

Давайте пройдемся по некоторым из этих случаев использования в пользу ripgrep. Некоторые из них могут не
применяться к вам. Это нормально. Могут быть другие случаи использования, не перечисленные здесь, которые
применяются к вам. Это тоже нормально.

(Для всех утверждений, связанных с производительностью в следующих словах, смотрите мой
[пост в блоге](https://blog.burntsushi.net/ripgrep/), представляющий ripgrep.)

* Вы часто ищете в репозитории кода? Если так, ripgrep может быть хорошим выбором, поскольку, вероятно, есть
  значительная часть вашего репозитория, которую вы не хотите искать. grep, конечно, можно заставить
  фильтровать файлы, используя рекурсивный поиск, и если вы не возражаете против написания необходимых правил
  `--exclude` или написания скриптов-оберток, то grep может быть достаточным. (Я не шучу, я сам делал это с
  grep почти десятилетие, прежде чем написать ripgrep.) Но если вместо этого вам нравится, когда инструмент
  поиска уважает ваш `.gitignore`, то ripgrep может быть идеальным для вас!
* Вы часто ищете не-ASCII текст, закодированный в UTF-8? Одна из ключевых функций ripgrep заключается в том,
  что он может обрабатывать функции Unicode в ваших шаблонах способом, который, как правило, быстрее, чем
  GNU grep. Функции Unicode в ripgrep включены по умолчанию; нет необходимости настраивать настройки локали
  для правильного использования ripgrep, потому что ripgrep не уважает настройки вашей локали.
* Вам нужно искать файлы UTF-16, и вы не хотите беспокоиться о явном перекодировании их? Отлично. ripgrep
  делает это для вас автоматически. Н��т необходимости включать это.
* Вам нужно искать в большом каталоге больших файлов? ripgrep использует параллелизм по умолчанию, что, как
  правило, делает его быстрее, чем стандартный поиск `grep -r`. Однако, если вы в порядке с написанием
  случайной команды `find ./ -print0 | xargs -P8 -0 grep`, то, возможно, grep достаточно хорош.

Вот некоторые случаи, когда вы можете *не* хотеть использовать ripgrep. Те же оговорки для предыдущего раздела
применяются.

* Вы пишете переносимые скрипты оболочки, предназначенные для работы в различных средах? Отлично, вероятно,
  не очень хорошая идея использовать ripgrep! ripgrep не имеет ничего подобного распространенности grep, поэтому,
  если вы используете ripgrep, вам, возможно, придется возиться с процессом установки больше, чем с grep.
* Вы заботитесь о совместимости с POSIX? Если так, то вы не можете использовать ripgrep, потому что он никогда
  не был, не является и никогда не будет совместим с POSIX.
* Вы ненавидите инструменты, которые пытаются сделать что-то умное? Если так, ripgrep весь о том, чтобы быть
  умным, поэтому вы можете предпочесть просто придерживаться grep.
* Есть ли конкретная функция grep, на которую вы полагаетесь, которой либо нет в ripgrep, либо никогда не будет?
  Если первое, сообщите об ошибке, возможно, ripgrep может это сделать! Если второе, ну, тогда просто используйте
  grep.


<h3 name="intentcountsforsomething">
Что означает "rip" в ripgrep?
</h3>

Когда я впервые начал писать ripgrep, я назвал его `rep`, намереваясь, чтобы это было более коротким вариантом
`grep`. Вскоре после этого я переименовал его в `xrep`, поскольку `rep` не было достаточно очевидным именем для
моего вкуса. А также потому, что добавление `x` ко всему всегда делает его лучше, верно?

Перед первым публичным релизом ripgrep я решил, что мне не нравится `xrep`. Я думал, что это немного неловко
печатать, и, несмотря на мою предыдущую похвалу буквы `x`, я вроде как думал, что это довольно паршиво. Будучи
кем-то, кто действительно любит Rust, я хотел назвать его "rustgrep" или, возможно, "rgrep" для краткости. Но я
думал, что это так же паршиво и, возможно, немного слишком в лицо. Но я хотел продолжать использовать `r`, чтобы
я мог по крайней мере притворяться, что Rust имеет к этому какое-то отношение.

Я провел пару дней, пытаясь придумать очень короткие слова, начинающиеся с буквы `r`, которые были бы хоть как-то
связаны с задачей поиска. Я не помню, как это всплыло в моей голове, но "rip" появилось как что-то, что означает
"быстро", как в "прорваться через ваш текст". Тот факт, что RIP также является аббревиатурой для "Rest in Peace"
(как в "ripgrep убивает grep"), никогда действительно не приходило мне в голову. Возможно, совпадение слишком
поразительно, чтобы поверить в это, но я не осознавал этого, пока кто-то явно не указал мне на это после
первоначального публичного релиза. Я признаю, что нашел это слегка забавным, но если бы я realized это сам перед
публичным релизом, я, вероятно, продолжил бы и выбрал другое имя. Увы, переименовывать вещи после релиза сложно,
поэтому я решил продолжить.

Учитывая тот факт, что [ripgrep никогда не был, не является и не будет 100% заменой grep](#posix4ever), ripgrep
никогда не был и никогда не предназначался быть "убийцей grep". Он, безусловно, вторгается в некоторые из его
случаев использования, но это ничем не отличается от того, что уже делали другие инструменты, такие как ack или
The Silver Searcher.


<h3 name="donations">
Как я могу сделать пожертвование ripgrep или его сопровождающим?
</h3>

Я приветствую [спонсорство](https://github.com/sponsors/BurntSushi/).

Или, если вы предпочитаете, пожертвование благотворительной организации, которая вам нравится, также будет
очень приветствоваться. Мои фавориты:

* [The Internet Archive](https://archive.org/donate/)
* [Rails Girls](https://railsgirlssummerofcode.org/)
* [Wikipedia](https://wikimediafoundation.org/support/)
