## Руководство пользователя

Это руководство предназначено для предоставления элементарного описания ripgrep и
обзора его возможностей. Это руководство предполагает, что ripgrep
[установлен](README.md#installation) и что читатели имеют поверхностное
знакомство с использованием инструментов командной строки. Также предполагается
Unix-подобная система, хотя большинство команд, вероятно, легко транслируются в
любую среду командной оболочки.


### Содержание

* [Основы](#basics)
* [Рекурсивный поиск](#recursive-search)
* [Автоматическая фильтрация](#automatic-filtering)
* [Ручная фильтрация: глобы](#manual-filtering-globs)
* [Ручная фильтрация: типы файлов](#manual-filtering-file-types)
* [Замены](#replacements)
* [Файл конфигурации](#configuration-file)
* [Кодировка файлов](#file-encoding)
* [Бинарные данные](#binary-data)
* [Препроцессор](#preprocessor)
* [Общие опции](#common-options)


### Основы

ripgrep — это инструмент командной строки, который ищет в ваших файлах шаблоны,
которые вы ему зададите. ripgrep ведет себя так, как если бы читал каждый файл
строка за строкой. Если строка соответствует шаблону, предоставленному ripgrep,
то эта строка будет напечатана. Если строка не соответствует шаблону, то строка
не печатается.

Лучший способ увидеть, как это работает — на примере. Чтобы показать пример, нам
нужно что-то для поиска. Давайте попробуем поискать в исходном коде ripgrep.
Сначала возьмите архив с исходным кодом ripgrep с
https://github.com/BurntSushi/ripgrep/archive/0.7.1.zip
и распакуйте его:

```
$ curl -LO https://github.com/BurntSushi/ripgrep/archive/0.7.1.zip
$ unzip 0.7.1.zip
$ cd ripgrep-0.7.1
$ ls
benchsuite  grep       tests         Cargo.toml       LICENSE-MIT
ci          ignore     wincolor      CHANGELOG.md     README.md
complete    pkg        appveyor.yml  compile          snapcraft.yaml
doc         src        build.rs      COPYING          UNLICENSE
globset     termcolor  Cargo.lock    HomebrewFormula
```

Давайте попробуем наш первый поиск, найдя все вхождения слова `fast` в `README.md`:

```
$ rg fast README.md
75:  faster than both. (N.B. It is not, strictly speaking, a "drop-in" replacement
88:  color and full Unicode support. Unlike GNU grep, `ripgrep` stays fast while
119:### Is it really faster than everything else?
124:Summarizing, `ripgrep` is fast because:
129:  optimizations to make searching very fast.
```

(**Примечание:** Если вы видите сообщение об ошибке от ripgrep, говорящее, что он
не искал ни в каких файлах, то перезапустите ripgrep с флагом `--debug`. Одна
вероятная причина этого в том, что у вас есть правило `*` в файле `$HOME/.gitignore`.)

Итак, что здесь произошло? ripgrep прочитал содержимое `README.md`, и для каждой
строки, которая содержала `fast`, ripgrep напечатал ее в ваш терминал. ripgrep
также включил номер строки для каждой строки по умолчанию. Если ваш терминал
поддерживает цвета, то ваш вывод может выглядеть примерно как этот скриншот:

[![Скриншот примера поиска с ripgrep](https://burntsushi.net/stuff/ripgrep-guide-sample.png)](https://burntsushi.net/stuff/ripgrep-guide-sample.png)

В этом примере мы искали так называемую "литеральную" строку. Это означает, что
наш шаблон был просто некоторым нормальным текстом, который мы попросили ripgrep
найти. Но ripgrep поддерживает возможность указания шаблонов через [регулярные
выражения](https://en.wikipedia.org/wiki/Regular_expression). В качестве примера,
что, если мы хотим найти все строки, имеющие слово, содержащее `fast`, за которым
следует некоторое количество других букв?

```
$ rg 'fast\w+' README.md
75:  faster than both. (N.B. It is not, strictly speaking, a "drop-in" replacement
119:### Is it really faster than everything else?
```

В этом примере мы использовали шаблон `fast\w+`. Этот шаблон говорит ripgrep
искать любые строки, содержащие буквы `fast`, за которыми следует *одна или более*
похожих на слова символов. А именно, `\w` соответствует символам, из которых
состоят слова (как `a` и `L`, но в отличие от `.` и ` `). `+` после `\w` означает
"сопоставить предыдущий шаблон один или более раз". Это означает, что слово `fast`
не совпадет, потому что нет символов слова после последней `t`. Но слово вроде
`faster` совпадет. `faste` также совпадет!

Вот другой вариант этой же темы:

```
$ rg 'fast\w*' README.md
75:  faster than both. (N.B. It is not, strictly speaking, a "drop-in" replacement
88:  color and full Unicode support. Unlike GNU grep, `ripgrep` stays fast while
119:### Is it really faster than everything else?
124:Summarizing, `ripgrep` is fast because:
129:  optimizations to make searching very fast.
```

В этом случае мы использовали `fast\w*` для нашего шаблона вместо `fast\w+`. `*`
означает, что он должен совпадать *ноль* или более раз. В этом случае ripgrep
напечатает те же строки, что и шаблон `fast`, но если ваш терминал поддерживает
цвета, вы заметите, что `faster` будет подсвечено вместо просто префикса `fast`.

Не входит в задачи этого руководства предоставлять полное руководство по регулярным
выражениям, но специфический синтаксис ripgrep задокументирован здесь:
https://docs.rs/regex/*/regex/#syntax


### Рекурсивный поиск

В предыдущем разделе мы показали, как использовать ripgrep для поиска в одном файле.
В этом разделе мы покажем, как использовать ripgrep для поиска во всем каталоге
файлов. Фактически, *рекурсивный* поиск вашего текущего рабочего каталога является
режимом работы ripgrep по умолчанию, что означает, что сделать это очень просто.

Используя нашу распакованную архивную копию исходного кода ripgrep, вот как найти
все определения функций с именем `write`:

```
$ rg 'fn write\('
src/printer.rs
469:    fn write(&mut self, buf: &[u8]) {

termcolor/src/lib.rs
227:    fn write(&mut self, b: &[u8]) -> io::Result<usize> {
250:    fn write(&mut self, b: &[u8]) -> io::Result<usize> {
428:    fn write(&mut self, b: &[u8]) -> io::Result<usize> { self.wtr.write(b) }
441:    fn write(&mut self, b: &[u8]) -> io::Result<usize> { self.wtr.write(b) }
454:    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
511:    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
848:    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
915:    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
949:    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
1114:    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
1348:    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
1353:    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
```

(**Примечание:** Мы экранируем `(` здесь, потому что `(` имеет специальное значение
внутри регулярных выражений. Вы также можете использовать `rg -F 'fn write('`, чтобы
добиться того же самого, где `-F` интерпретирует ваш шаблон как литературную строку
вместо регулярного выражения.)

В этом примере мы не указали файл вообще. Вместо этого ripgrep по умолчанию искал в
вашем текущем каталоге при отсутствии пути. В целом, `rg foo` эквивалентно `rg foo ./`.

Этот конкретный поиск показал нам результаты как в каталоге `src`, так и в `termcolor`.
Каталог `src` — это основное ядро кода ripgrep, тогда как `termcolor` — это зависимость
ripgrep (и используется другими инструментами). Что, если мы хотим искать только в
основном коде ripgrep? Что ж, это просто, просто укажите каталог, который вы хотите:

```
$ rg 'fn write\(' src
src/printer.rs
469:    fn write(&mut self, buf: &[u8]) {
```

Здесь ripgrep ограничил свой поиск каталогом `src`. Другой способ выполнить этот
поиск — `cd` в каталог `src` и снова использовать `rg 'fn write\('`.


### Автоматическая фильтрация

После рекурсивного поиска, самая важная функция ripgrep — это то, что он *не* ищет.
По умолчанию, когда вы ищете в каталоге, ripgrep игнорирует все следующее:

1. Файлы и каталоги, которые соответствуют шаблонам glob в этих трех категориях:
      1. Глобы `.gitignore` (включая глобальные и специфичные для репозитория глобы).
         Это включает файлы `.gitignore` в родительских каталогах, которые являются
         частью того же репозитория `git`. (Если не указан флаг `--no-require-git`.)
      2. Глобы `.ignore`, которые имеют приоритет над всеми глобами gitignore при
         конфликте. Это включает файлы `.ignore` в родительских каталогах.
      3. Глобы `.rgignore`, которые имеют приоритет над всеми глобами `.ignore` при
         конфликте. Это включает файлы `.rgignore` в родительских каталогах.
2. Скрытые файлы и каталоги.
3. Бинарные файлы. (ripgrep считает любой файл с байтом `NUL` бинарным.)
4. Символические ссылки не обходятся.

Все эти вещи можно переключить с помощью различных флагов, предоставленных ripgrep:

1. Вы можете отключить всю фильтрацию, связанную с игнорированием, с помощью флага
   `--no-ignore`.
2. Скрытые файлы и каталоги можно искать с помощью флага `--hidden` (`-.` для краткости).
3. Бинарные файлы можно искать с помощью флага `--text` (`-a` для краткости).
   Будьте осторожны с этим флагом! Бинарные файлы могут выдавать управляющие символы
   в ваш терминал, что может вызвать странное поведение.
4. ripgrep может обходить символьные ссылки с помощью флага `--follow` (`-L` для краткости).

В качестве специального удобства, ripgrep также предоставляет флаг с именем
`--unrestricted` (`-u` для краткости). Повторное использование этого флага заставит
ripgrep отключать все больше и больше своей фильтрации. То есть, `-u` отключит
обработку `.gitignore`, `-uu` будет искать скрытые файлы и каталоги, а `-uuu` будет
искать бинарные файлы. Это полезно, когда вы используете ripgrep и не уверены,
скрывает ли его фильтрация результаты от вас. Добавление пары флагов `-u` — это
быстрый способ выяснить это. (Используйте флаг `--debug`, если вы все еще озадачены,
и если это не поможет, [сообщите об проблеме](https://github.com/BurntSushi/ripgrep/issues/new).)

Обработка `.gitignore` в ripgrep на самом деле идет немного дальше, чем просто файлы
`.gitignore`. ripgrep также будет уважать специфичные для репозитория правила, найденные
в `$GIT_DIR/info/exclude`, а также любые правила глобального игнорирования в вашем
`core.excludesFile` (который обычно `$XDG_CONFIG_HOME/git/ignore` в Unix-подобных системах).

Иногда вы хотите искать файлы, которые находятся в вашем `.gitignore`, поэтому можно
указать дополнительные правила игнорирования или переопределения в файле `.ignore`
(независимом от приложения) или `.rgignore` (специфичном для ripgrep).

Например, скажем, у вас есть файл `.gitignore`, который выглядит так:

```
log/
```

Это обычно означает, что любой каталог `log` не будет отслеживаться `git`. Однако,
возможно, он содержит полезный вывод, который вы хотели бы включить в ваши поиски,
но вы все еще не хотите отслеживать его в `git`. Вы можете добиться этого, создав
файл `.ignore` в том же каталоге, что и файл `.gitignore`, со следующим содержимым:

```
!log/
```

ripgrep обрабатывает файлы `.ignore` с более высоким приоритетом, чем файлы `.gitignore`
(и обрабатывает файлы `.rgignore` с более высоким приоритетом, чем файлы `.ignore`).
Это означает, что ripgrep сначала увидит правило белого списка `!log/` и будет искать
в этом каталоге.

Как и `.gitignore`, файл `.ignore` может быть размещен в любом каталоге. Его правила
будут обрабатываться относительно каталога, в котором он находится, так же, как и
`.gitignore`.

Для обработки файлов `.gitignore` и `.ignore` без учета регистра используйте флаг
`--ignore-file-case-insensitive`. Это особенно полезно на файловых системах без учета
регистра, таких как в Windows и macOS. Однако обратите внимание, что это может привести
к значительному снижению производительности и поэтому отключено по умолчанию.

Для более подробного описания того, как интерпретируются шаблоны glob в файле `.gitignore`,
пожалуйста, смотрите `man gitignore`.


### Ручная фильтрация: глобы

В предыдущем разделе мы говорили о фильтрации, которую ripgrep выполняет по умолчанию.
Она "автоматическая", потому что реагирует на вашу среду. То есть, она использует уже
существующие файлы `.gitignore` для получения более релевантных результатов поиска.

В дополнение к автоматической фильтрации, ripgrep также предоставляет более ручную или
специальную фильтрацию. Это бывает двух видов: дополнительные шаблоны glob, указанные в
ваших командах ripgrep, и фильтрация по типу файлов. Этот раздел охватывает шаблоны glob,
а следующий раздел охватывает фильтрацию по типу файлов.

В нашем исходном коде ripgrep (смотрите [Основы](#basics) для инструкций о том, как
получить архив с исходным кодом для поиска), скажем, мы хотим увидеть, что зависит от
`clap`, нашего парсера аргументов.

Мы могли бы сделать это:

```
$ rg clap
[много результатов]
```

Но это показывает нам много вещей, а нас интересуют только места, где мы написали `clap`
как зависимость. Вместо этого мы могли бы ограничиться файлами TOML, которые используются
для указания зависимостей в инструменте сборки Cargo для Rust:

```
$ rg clap -g '*.toml'
Cargo.toml
35:clap = "2.26"
51:clap = "2.26"
```

Синтаксис `-g '*.toml'` говорит: "убедитесь, что каждый искомый файл соответствует этому
шаблону glob". Обратите внимание, что мы поместили `'*.toml'` в одинарные кавычки, чтобы
предотвратить раскрытие `*` нашей оболочкой.

Если бы мы захотели, мы могли бы сказать ripgrep искать все, что угодно, *кроме* файлов `*.toml`:

```
$ rg clap -g '!*.toml'
[много результатов]
```

Это снова даст вам много результатов, как выше, но они не будут включать файлы, оканчивающиеся
на `.toml`. Обратите внимание, что использование `!` здесь для обозначения "отрицания" немного
нестандартно, но было выбрано для согласованности с тем, как пишутся глобы в файлах `.gitignore`.
(Хотя значение обратное. В файлах `.gitignore` префикс `!` означает белый список, а в командной
строке `!` означает черный список.)

Глобы интерпретируются точно так же, как шаблоны `.gitignore`. То есть, более поздние глобы
переопределяют более ранние глобы. Например, следующая команда будет искать только файлы `*.toml`:

```
$ rg clap -g '!*.toml' -g '*.toml'
```

Интересно, что изменение порядка глобов в этом случае не даст никаких совпадений, поскольку наличие
хотя бы одного не-черного списка глобов установит требование, чтобы каждый искомый файл соответствовал
хотя бы одному глобу. В этом случае глоб черного списка имеет приоритет над предыдущим глобом и
предотвращает поиск любого файла вообще!


### Ручная фильтрация: типы файлов

Со временем вы можете заметить, что используете одни и те же шаблоны glob снова и снова. Например,
вы можете обнаружить, что выполняете много поисков, где вы хотите видеть результаты только для
файлов Rust:

```
$ rg 'fn run' -g '*.rs'
```

Вместо того, чтобы писать glob каждый раз, вы можете использовать поддержку типов файлов ripgrep:

```
$ rg 'fn run' --type rust
```

или, более кратко,

```
$ rg 'fn run' -trust
```

Способ работы флага `--type` прост. Он действует как имя, присвоенное одному или нескольким глобам,
которые соответствуют соответствующим файлам. Это позволяет вам написать один тип, который может
охватывать широкий диапазон расширений файлов. Например, если вы хотите искать файлы C, вам придется
проверять как исходные файлы C, так и заголовочные файлы C:

```
$ rg 'int main' -g '*.{c,h}'
```

или вы можете просто использовать тип файла C:

```
$ rg 'int main' -tc
```

Так же, как вы можете писать глобы черного списка, вы также можете заносить в черный список типы файлов:

```
$ rg clap --type-not rust
```

или, более кратко,

```
$ rg clap -Trust
```

То есть, `-t` означает "включить файлы этого типа", тогда как `-T` означает "исключить файлы этого типа".

Чтобы увидеть глобы, из которых состоит тип, запустите `rg --type-list`:

```
$ rg --type-list | rg '^make:'
make: *.mak, *.mk, GNUmakefile, Gnumakefile, Makefile, gnumakefile, makefile
```

По умолчанию ripgrep поставляется с множеством предопределенных типов. Как правило, эти типы
соответствуют хорошо известным общедоступным форматам. Но вы также можете определить свои собственные
типы. Например, возможно, вы часто ищете "веб" файлы, которые состоят из JavaScript, HTML и CSS:

```
$ rg --type-add 'web:*.html' --type-add 'web:*.css' --type-add 'web:*.js' -tweb title
```

или, более кратко,

```
$ rg --type-add 'web:*.{html,css,js}' -tweb title
```

Приведенная выше команда определяет новый тип `web`, соответствующий глобу `*.{html,css,js}`. Затем
она применяет новый фильтр с `-tweb` и ищет шаблон `title`. Если бы вы запустили

```
$ rg --type-add 'web:*.{html,css,js}' --type-list
```

Тогда вы бы увидели свой тип `web` в списке, даже though он не является встроенным типом ripgrep.

Здесь важно подчеркнуть, что флаг `--type-add` применяется только к текущей команде. Он не добавляет
новый тип файла и не сохраняет его где-либо в постоянной форме. Если вы хотите, чтобы тип был доступен
в каждой команде ripgrep, то вы должны либо создать псевдоним оболочки:

```
alias rg="rg --type-add 'web:*.{html,css,js}'"
```

или добавить `--type-add=web:*.{html,css,js}` в ваш файл конфигурации ripgrep. ([Файлы конфигурации](#configuration-file)
рассматриваются более подробно позже.)

#### Специальный тип файла `all`

Специальная опция, поддерживаемая флагом `--type`, — это `all`. `--type all` ищет совпадение в любом
из поддерживаемых типов файлов, перечисленных в `--type-list`, включая те, которые добавлены в командной
строке с помощью `--type-add`. Это эквивалентно команде `rg --type agda --type asciidoc --type asm ...`,
где `...` означает список флагов `--type` для остальных типов в `--type-list`.

В качестве примера предположим, что у вас есть скрипт оболочки в вашем текущем каталоге, `my-shell-script`,
который включает библиотеку оболочки, `my-shell-library.bash`. И `rg --type sh`, и `rg --type all` будут
искать совпадения только в `my-shell-library.bash`, а не в `my-shell-script`, потому что глобы,
сопоставленные типом файла `sh`, не включают файлы без расширения. С другой стороны, `rg --type-not all`
будет искать в `my-shell-script`, но не в `my-shell-library.bash`.

### Замены

ripgrep предоставляет ограниченную возможность изменять свой вывод, заменяя найденный текст некоторым
другим текстом. Это легче всего объяснить на примере. Помните, когда мы искали слово `fast` в README
ripgrep?

```
$ rg fast README.md
75:  faster than both. (N.B. It is not, strictly speaking, a "drop-in" replacement
88:  color and full Unicode support. Unlike GNU grep, `ripgrep` stays fast while
119:### Is it really faster than everything else?
124:Summarizing, `ripgrep` is fast because:
129:  optimizations to make searching very fast.
```

Что, если мы хотим *заменить* все вхождения `fast` на `FAST`? Это просто с флагом `--replace` ripgrep:

```
$ rg fast README.md --replace FAST
75:  FASTer than both. (N.B. It is not, strictly speaking, a "drop-in" replacement
88:  color and full Unicode support. Unlike GNU grep, `ripgrep` stays FAST while
119:### Is it really FASTer than everything else?
124:Summarizing, `ripgrep` is FAST because:
129:  optimizations to make searching very FAST.
```

или, более кратко,

```
$ rg fast README.md -r FAST
[вырезано]
```

По сути, флаг `--replace` применяется *только* к соответствующей части текста в выводе. Если вместо этого
вы хотите заменить всю строку текста, то вам нужно включить всю строку в ваше совпадение. Например:

```
$ rg '^.*fast.*$' README.md -r FAST
75:FAST
88:FAST
119:FAST
124:FAST
129:FAST
```

В качестве альтернативы, вы можете объединить флаг `--only-matching` (или `-o` для краткости) с флагом
`--replace` для достижения того же результата:

```
$ rg fast README.md --only-matching --replace FAST
75:FAST
88:FAST
119:FAST
124:FAST
129:FAST
```

или, более кратко,

```
$ rg fast README.md -or FAST
[вырезано]
```

Наконец, замены могут включать группы захвата. Например, скажем, мы хотим найти все вхождения `fast`,
за которыми следует другое слово, и соединить их вместе с тире. Шаблон, который мы могли бы использовать
для этого, — `fast\s+(\w+)`, который соответствует `fast`, за которым следует любое количество пробельных
символов, за которым следует любое количество "словных" символов. Мы поместили `\w+` в "группу захвата"
(обозначено скобками), чтобы мы могли ссылаться на нее позже в нашей строке замены. Например:

```
$ rg 'fast\s+(\w+)' README.md -r 'fast-$1'
88:  color and full Unicode support. Unlike GNU grep, `ripgrep` stays fast-while
124:Summarizing, `ripgrep` is fast-because:
```

Наша строка замены здесь, `fast-$1`, состоит из `fast-`, за которым следует содержимое группы захвата с
индексом `1`. (Группы захвата фактически начинаются с индекса 0, но `0`-я группа захвата всегда соответствует
всему совпадению. Группа захвата с индексом `1` всегда соответствует первой явной группе захвата, найденной
в шаблоне regex.)

Группы захвата также могут быть именованными, что иногда удобнее, чем использование индексов. Например,
следующая команда эквивалентна приведенной выше команде:

```
$ rg 'fast\s+(?P<word>\w+)' README.md -r 'fast-$word'
88:  color and full Unicode support. Unlike GNU grep, `ripgrep` stays fast-while
124:Summarizing, `ripgrep` is fast-because:
```

Важно отметить, что ripgrep **никогда не модифицирует ваши файлы**. Флаг `--replace` управляет только
выводом ripgrep. (И нет флага, который позволил бы вам выполнить замену в файле.)


### Файл конфигурации

Возможно, параметры ripgrep по умолчанию не подходят в каждом случае. По этой причине и потому, что
псевдонимы оболочки не всегда удобны, ripgrep поддерживает файлы конфигурации.

Настройка файла конфигурации проста. ripgrep не будет автоматически искать файл конфигурации в каком-либо
предопределенном каталоге. Вместо этого вам нужно установить переменную окружения `RIPGREP_CONFIG_PATH` в
путь к вашему файлу конфигурации. Как только переменная окружения установлена, откройте файл и просто
введите флаги, которые вы хотите установить автоматически. Есть только два правила для описания формата
файла конфигурации:

1. Каждая строка — это аргумент оболочки, после обрезки пробельных символов.
2. Строки, начинающиеся с `#` (опционально предваренные любым количеством пробельных символов), игнорируются.

В частности, нет экранирования. Каждая строка передается ripgrep как единый аргумент командной строки
дословно.

Вот пример файла конфигурации, который демонстрирует некоторые особенности форматирования:

```
$ cat $HOME/.ripgreprc
# Не позволять ripgrep вываливать действительно длинные строки в мой терминал и показывать предпросмотр.
--max-columns=150
--max-columns-preview

# Добавить мой тип 'web'.
--type-add
web:*.{html,css,js}*

# Искать скрытые файлы / каталоги (например, dotfiles) по умолчанию
--hidden

# Использование шаблонов glob для включения/исключения файлов или каталогов
--glob=!.git/*

# или
--glob
!.git/*

# Установить цвета.
--colors=line:none
--colors=line:style:bold

# Потому что кого волнует регистр!?
--smart-case
```

Когда мы используем флаг, имеющий значение, мы либо помещаем флаг и значение в одну строку, но разделенные
знаком `=` (например, `--max-columns=150`), либо помещаем флаг и значение в две разные строки. Это потому,
что парсер аргументов ripgrep знает, как трактовать единый аргумент `--max-columns=150` как флаг со значением,
но если бы мы написали `--max-columns 150` в нашем файле конфигурации, то парсер аргументов ripgrep не знал
бы, что с этим делать.

Помещение флага и значения в разные строки точно эквивалентно и является вопросом стиля.

Комментарии приветствуются, чтобы вы помнили, что делает конфигурация. Пустые строки тоже в порядке.

Итак, скажем, вы используете приведенный выше файл конфигурации, но пока вы находитесь в терминале, вы
действительно хотите видеть строки длиннее 150 колонок. Что вы делаете? К счастью, все, что вам нужно
сделать, — это передать `--max-columns 0` (или `-M0` для краткости) в командной строке, что переопределит
настройку вашего файла конфигурации. Это работает, потому что файл конфигурации ripgrep *предшествует*
явным аргументам, которые вы даете ему в командной строке. Поскольку флаги, данные позже, переопределяют
флаги, данные ранее, все работает как ожидалось. Это работает для большинства других флагов, и документация
каждого флага указывает, какие другие флаги переопределяют его.

Если вы запутались в том, из какого файла конфигурации ripgrep читает аргументы, то запуск ripgrep с флагом
`--debug` должен помочь прояснить вещи. Вывод отладки должен отметить, какой файл конфигурации загружается,
и аргументы, которые были прочитаны из конфигурации.

Наконец, если вы хотите абсолютно убедиться, что ripgrep *не* читает файл конфигурации, то вы можете передать
флаг `--no-config`, который всегда предотвратит чтение ripgrep посторонней конфигурации из окружения,
независимо от того, какие другие методы конфигурации будут добавлены в ripgrep в будущем.


### Кодировка файлов

[Кодировка текста](https://en.wikipedia.org/wiki/Character_encoding) — сложная тема, но мы можем попытаться
резюмировать ее актуальность для ripgrep:

* Файлы обычно представляют собой набор байтов. Нет надежного способа узнать их кодировку.
* Либо кодировка шаблона должна соответствовать кодировке искомых файлов, либо должна быть выполнена форма
  перекодирования, которая преобразует либо шаблон, либо файл в ту же кодировку, что и другой.
* ripgrep, как правило, лучше всего работает с простыми текстовыми файлами, и среди простых текстовых файлов
  наиболее популярные кодировки, вероятно, состоят из ASCII, latin1 или UTF-8. В качестве специального
  исключения, UTF-16 распространена в средах Windows.

В свете вышеизложенного, вот как ripgrep ведет себя, когда дано `--encoding auto`, что является значением
по умолчанию:

* Весь ввод предполагается совместимым с ASCII (что означает, что каждый байт, соответствующий кодовой точке
  ASCII, фактически является кодовой точкой ASCII). Это включает сам ASCII, latin1 и UTF-8.
* ripgrep лучше всего работает с UTF-8. Например, движок регулярных выражений ripgrep поддерживает функции
  Unicode. А именно, классы символов, такие как `\w`, будут соответствовать всем словным символам по определению
  Unicode ... [обрезано]
  Unicode codepoint вместо любого байта. Эти конструкции предполагают UTF-8, поэтому они просто не совпадут,
  когда сталкиваются с байтами в файле, которые не являются UTF-8.
* Для обработки случая UTF-16, ripgrep по умолчанию сделает что-то под названием "BOM sniffing". То есть, первые
  три байта файла будут прочитаны, и если они соответствуют UTF-16 BOM, то ripgrep перекодирует содержимое файла
  из UTF-16 в UTF-8, а затем выполнит поиск на перекодированной версии файла. (Это влечет за собой штраф
  производительности, поскольку требуется перекодирование в дополнение к поиску regex.) Если файл содержит
  недопустимый UTF-16, то код замены Unicode подставляется вместо недопустимых кодовых единиц.
* Для обработки других случаев, ripgrep предоставляет флаг `-E/--encoding`, который позволяет вам указать кодировку
  из [Encoding Standard](https://encoding.spec.whatwg.org/#concept-encoding-get). ripgrep будет предполагать, что
  *все* искомые файлы имеют указанную кодировку (если только файл не имеет BOM) и выполнит шаг перекодирования,
  как в случае UTF-16, описанном выше.

По умолчанию ripgrep не требует, чтобы его ввод был действительным UTF-8. То есть, ripgrep может и будет искать
произвольные байты. Ключ здесь в том, что если вы ищете контент, который не является UTF-8, то полезность вашего
шаблона ухудшится. Если вы ищете байты, которые не совместимы с ASCII, то вероятно, шаблон ничего не найдет. При
всем сказанном, этот режим работы важен, потому что он позволяет вам находить ASCII или UTF-8 *внутри* файлов,
которые в остальном являются произвольными байтами.

В качестве особого случая, флаг `-E/--encoding` поддерживает значение `none`, которое полностью отключит всю
логику, связанную с кодировкой, включая BOM sniffing. Когда `-E/--encoding` установлен в `none`, ripgrep будет
искать сырые байты базового файла без шага перекодирования. Например, вот как вы можете искать сырое UTF-16
кодирование строки `Шерлок`:

```
$ rg '(?-u)\(\x045\x04@\x04;\x04>\x04:\x04' -E none -a some-utf16-file
```

Конечно, это просто пример, предназначенный для показа, как можно опуститься до сырых байтов. А именно, более
простая команда работает, как вы могли ожидать, автоматически:

```
$ rg 'Шерлок' some-utf16-file
```

Наконец, можно отключить поддержку Unicode ripgrep изнутри регулярного выражения. Например, скажем, вы хотите,
чтобы `.` соответствовал любому байту, а не любой кодовой точке Unicode. (Вы можете захотеть этого при поиске
бинарного файла, поскольку `.` по умолчанию не будет соответствовать недопустимому UTF-8.) Вы можете сделать это,
отключив Unicode через флаг регулярного выражения:

```
$ rg '(?-u:.)'
```

Это работает для любой части шаблона. Например, следующее найдет любой словный символ Unicode, за которым следует
любой словный символ ASCII, за которым следует еще один словный символ Unicode:

```
$ rg '\w(?-u:\w)\w'
```


### Бинарные данные

В дополнение к пропуску скрытых файлов и файлов в вашем `.gitignore` по умолчанию, ripgrep также пытается
пропускать бинарные файлы. ripgrep делает это по умолчанию, потому что бинарные файлы (такие как PDF или
изображения) обычно не являются тем, что вы хотите искать при поиске совпадений regex. Более того, если
содержимое в бинарном файле совпало, то возможно, что нежелательные бинарные данные будут напечатаны в ваш
терминал и вызовут хаос.

К сожалению, в отличие от пропуска скрытых файлов и уважения ваших правил `.gitignore`, файл не может быть так
же легко классифицирован как бинарный. Чтобы выяснить, является ли файл бинарным, наиболее эффективная эвристика,
балансирующая правильность с производительностью, — это просто искать байты `NUL`. На этом этапе определение
просто: файл считается "бинарным", если и только если он содержит байт `NUL` где-то в своем содержимом.

Проблема в том, что хотя большинство бинарных файлов будут иметь байт `NUL` в начале своего содержимого, это не
обязательно так. Байт `NUL` может быть самым последним байтом в большом файле, но этот файл все еще считается
бинарным. Хотя это приводит к изрядному количеству сложности внутри реализации ripgrep, это также приводит к
некоторым неинтуитивным пользовательским опытам.

На высоком уровне ripgrep работает в трех различных режимах по отношению к бинарным файлам:

1. Режим по умолчанию — попытаться полностью удалить бинарные файлы из поиска. Это предназначено для зеркального
   отражения того, как ripgrep автоматически удаляет скрытые файлы и файлы в вашем `.gitignore`. То есть, как
   только файл обнаружен как бинарный, поиск останавливается. Если совпадение уже было напечатано (потому что
   оно было обнаружено задолго до байта `NUL`), то ripgrep напечатает предупреждающее сообщение, указывающее,
   что поиск остановился преждевременно. Этот режим по умолчанию **применяется только к файлам, искомых ripgrep
   в результате рекурсивного обхода каталогов**, что согласуется с другой автоматической фильтрацией ripgrep.
   Например, `rg foo .file` будет искать `.file`, даже though он скрыт. Аналогично, `rg foo binary-file` будет
   искать `binary-file` в режиме "бинарный" автоматически.
2. Бинарный режим похож на режим по умолчанию, за исключением того, что он не всегда останавливает поиск после
   того, как увидит байт `NUL`. А именно, в этом режиме ripgrep продолжит поиск файла, который, как известно,
   является бинарным, пока не будет выполнено первое из двух условий: 1) достигнут конец файла или 2) совпадение
   есть или было увидено. Это означает, что в бинарном режиме, если ripgrep сообщает об отсутствии совпадений,
   то в файле нет совпадений. Когда совпадение происходит, ripgrep печатает сообщение, подобное тому, которое
   он печатает в своем режиме по умолчанию, указывающее, что поиск остановился преждевременно. Этот режим можно
   принудительно включить для всех файлов с помощью флага `--binary`. Цель бинарного режима — предоставить способ
   обнаружения совпадений во всех файлах, но избежать попадания бинарных данных в ваш терминал.
3. Текстовый режим полностью отключает все обнаружение бинарных файлов и ищет все файлы, как если бы они были
   текстом. Это полезно при поиске файла, который преимущественно текст, но содержит байт `NUL`, или если вы
   специально пытаетесь искать бинарные данные. Этот режим можно включить с помощью флага `-a/--text`. Обратите
   внимание, что при использовании этого режима на очень больших бинарных файлах, возможно, ripgrep будет
   использовать много памяти.

К сожалению, есть одна дополнительная сложность в ripgrep, которая может затруднить рассуждение о бинарных файлах.
То есть, способ обнаружения бинарных файлов зависит от того, как ripgrep ищет ваши файлы. В частности:

* Когда ripgrep использует отображение памяти, то обнаружение бинарных файлов выполняется только на первых нескольких
  килобайтах файла в дополнение к каждой совпавшей строке.
* Когда ripgrep не использует отображение памяти, то обнаружение бинарных файлов выполняется на всех искомых байтах.

Это означает, что то, является ли файл обнаруженным как бинарный или нет, может измениться в зависимости от
внутренней стратегии поиска, используемой ripgrep. Если вы предпочитаете保持一致ность обнаружения бинарных файлов
ripgrep, то вы можете отключить отображение памяти через флаг `--no-mmap`. (Ценой будет небольшая регрессия
производительности при поиске очень больших файлов на некоторых платформах.)


### Препроцессор

В ripgrep препроцессор — это любой тип команды, которая может быть запущена для преобразования ввода каждого
файла перед тем, как ripgrep ищет его. Это делает возможным поиск практически любого вида контента, который
может быть автоматически преобразован в текст, без необходимости обучать ripgrep, как читать указанный контент.

Один распространенный пример — поиск в PDF. PDF в первую очередь предназначены для отображения пользователям.
Но PDF часто имеют текстовые потоки в них, которые могут быть полезны для поиска. В нашем случае мы хотим искать
отличную диссертацию Брюса Ватсона,
[Taxonomies and Toolkits of Regular Language Algorithms](https://burntsushi.net/stuff/1995-watson.pdf).
После загрузки, давайте попробуем поискать в ней:

```
$ rg 'The Commentz-Walter algorithm' 1995-watson.pdf
$
```

Конечно, диссертация по алгоритмам регулярных языков должна упоминать Commentz-Walter. Действительно, это так,
но наш поиск не улавливает это, потому что PDF являются бинарным форматом, и текст, показанный в PDF, может не
быть закодирован как простое непрерывное UTF-8. А именно, даже передача флага `-a/--text` ripgrep не заставит
наш поиск работать.

Один из способов исправить это — сначала преобразовать PDF в простой текст. Это не будет хорошо работать для всех
PDF, но отлично справляется во многих случаях. (Обратите внимание, что инструмент, который мы используем, `pdftotext`,
является частью библиотеки рендеринга PDF [poppler](https://poppler.freedesktop.org).)

```
$ pdftotext 1995-watson.pdf > 1995-watson.txt
$ rg 'The Commentz-Walter algorithm' 1995-watson.txt
316:The Commentz-Walter algorithms : : : : : : : : : : : : : : :
7165:4.4 The Commentz-Walter algorithms
10062:in input string S , we obtain the Boyer-Moore algorithm. The Commentz-Walter algorithm
17218:The Commentz-Walter algorithm (and its variants) displayed more interesting behaviour,
17249:Aho-Corasick algorithms are used extensively. The Commentz-Walter algorithms are used
17297: The Commentz-Walter algorithms (CW). In all versions of the CW algorithms, a common program skeleton is used with di erent shift functions. The CW algorithms are
```

Но необходимость явно преобразовывать каждый файл может быть болезненной, особенно когда у вас есть каталог,
полный файлов PDF. Вместо этого мы можем использовать функцию препроцессора ripgrep для поиска в PDF. Флаг
`--pre` ripgrep работает, принимая одно имя команды и затем выполняя эту команду для каждого файла, который он
ищет. ripgrep передает путь к файлу в качестве первого и единственного аргумента команде, а также отправляет
содержимое файла в stdin. Итак, давайте напишем простой скрипт оболочки, который оборачивает `pdftotext` способом,
соответствующим этому интерфейсу:

```
$ cat preprocess
#!/bin/sh

exec pdftotext - -
```

С `preprocess` в том же каталоге, что и `1995-watson.pdf`, мы теперь можем использовать его для поиска в PDF:

```
$ rg --pre ./preprocess 'The Commentz-Walter algorithm' 1995-watson.pdf
316:The Commentz-Walter algorithms : : : : : : : : : : : : : : :
7165:4.4 The Commentz-Walter algorithms
10062:in input string S , we obtain the Boyer-Moore algorithm. The Commentz-Walter algorithm
17218:The Commentz-Walter algorithm (and its variants) displayed more interesting behaviour,
17249:Aho-Corasick algorithms are used extensively. The Commentz-Walter algorithms are used
17297: The Commentz-Walter algorithms (CW). In all versions of the CW algorithms, a common program skeleton is used with di erent shift functions. The CW algorithms are
```

Обратите внимание, что `preprocess` должен быть разрешим в команду, которую ripgrep может прочитать. Простейший
способ сделать это — поместить вашу команду препроцессора в каталог, который находится в вашем `PATH` (или
эквиваленте), или иначе использовать абсолютный путь.

В качестве бонуса, это оказывается значительно быстрее, чем другие специализированные инструменты поиска PDF:

```
$ time rg --pre ./preprocess 'The Commentz-Walter algorithm' 1995-watson.pdf -c
6

real    0.697
user    0.684
sys     0.007
maxmem  16 MB
faults  0

$ time pdfgrep 'The Commentz-Walter algorithm' 1995-watson.pdf -c
6

real    1.336
user    1.310
sys     0.023
maxmem  16 MB
faults  0
```

Если вам в конечном итоге понадобится искать много PDF, то параллелизм ripgrep может сделать разницу в скорости
еще больше.

#### Более надежный препроцессор

Одна из проблем с вышеупомянутым препроцессором в том, что он потерпит неудачу, если вы попытаетесь искать файл,
который не является PDF:

```
$ echo foo > not-a-pdf
$ rg --pre ./preprocess 'The Commentz-Walter algorithm' not-a-pdf
not-a-pdf: preprocessor command failed: '"./preprocess" "not-a-pdf"':
-------------------------------------------------------------------------------
Syntax Warning: May not be a PDF file (continuing anyway)
Syntax Error: Couldn't find trailer dictionary
Syntax Error: Couldn't find trailer dictionary
Syntax Error: Couldn't read xref table
```

Чтобы исправить это, мы можем сделать наш скрипт препроцессора немного более надежным, запуская `pdftotext` только
когда мы думаем, что ввод является непустым PDF:

```
$ cat preprocessor
#!/bin/sh

case "$1" in
*.pdf)
  # Флаг -s гарантирует, что файл непустой.
  if [ -s "$1" ]; then
    exec pdftotext - -
  else
    exec cat
  fi
  ;;
*)
  exec cat
  ;;
esac
```

Мы даже можем расширить наш препроцессор для поиска других видов файлов. Иногда мы не всегда знаем тип файла из
имени файла, поэтому мы можем использовать утилиту `file` для "нюхания" типа файла на основе его содержимого:

```
$ cat processor
#!/bin/sh

case "$1" in
*.pdf)
  # Флаг -s гарантирует, что файл непустой.
  if [ -s "$1" ]; then
    exec pdftotext - -
  else
    exec cat
  fi
  ;;
*)
  case $(file "$1") in
  *Zstandard*)
    exec pzstd -cdq
    ;;
  *)
    exec cat
    ;;
  esac
  ;;
esac
```

#### Уменьшение накладных расходов препроцессора

Есть еще одна проблема с вышеупомянутым подходом: он требует запуска препроцессора для каждого отдельного файла,
который ищет ripgrep. Если каждый файл нуждается в препроцессоре, то это в порядке. Но если большинство не нуждается,
то это может существенно замедлить поиск из-за накладных расходов на запуск новых процессоров. Вы можете избежать
этого, указав ripgrep вызывать препроцессор только когда путь к файлу соответствует глобу. Например, рассмотрите
разницу в производительности даже при поиске в репозитории размером с ripgrep:

```
$ time rg --pre pre-rg 'fn is_empty' -c
crates/globset/src/lib.rs:1
crates/matcher/src/lib.rs:2
crates/ignore/src/overrides.rs:1
crates/ignore/src/gitignore.rs:1
crates/ignore/src/types.rs:1

real    0.138
user    0.485
sys     0.209
maxmem  7 MB
faults  0

$ time rg --pre pre-rg --pre-glob '*.pdf' 'fn is_empty' -c
crates/globset/src/lib.rs:1
crates/ignore/src/types.rs:1
crates/ignore/src/gitignore.rs:1
crates/ignore/src/overrides.rs:1
crates/matcher/src/lib.rs:2

real    0.008
user    0.010
sys     0.002
maxmem  7 MB
faults  0
```


### Общие опции

У ripgrep много флагов. Слишком много, чтобы держать их все в голове сразу. Этот раздел предназначен для того,
чтобы дать вам выборку некоторых из наиболее важных и часто используемых опций, которые, вероятно, повлияют на
то, как вы используете ripgrep на регулярной основе.

* `-h`: Показать сжатую справку ripgrep.
* `--help`: Показать более длинную форму справки ripgrep. (Почти то, что вы нашли бы в странице руководства man
  ripgrep, поэтому передайте в пейджер!)
* `-i/--ignore-case`: При поиске шаблона игнорировать различия регистра. То есть `rg -i fast` соответствует
  `fast`, `fASt`, `FAST` и т.д.
* `-S/--smart-case`: Это похоже на `--ignore-case`, но отключается, если шаблон содержит любые заглавные буквы.
  Обычно этот флаг помещается в псевдоним или файл конфигурации.
* `-F/--fixed-strings`: Отключить соп��ставление регулярных выражений и трактовать шаблон как литературную строку.
* `-w/--word-regexp`: Требовать, чтобы все совпадения шаблона были окружены границами слов. То есть, учитывая
  `pattern`, флаг `--word-regexp` заставит ripgrep вести себя так, как если бы `pattern` было на самом деле
  `\b(?:pattern)\b`.
* `-c/--count`: Сообщить количество общих совпавших строк.
* `--files`: Напечатать файлы, которые ripgrep *будет* искать, но не искать их фактически.
* `-a/--text`: Искать бинарные файлы, как если бы они были простым текстом.
* `-U/--multiline`: Разрешить совпадениям охватывать несколько строк.
* `-z/--search-zip`: Искать сжатые файлы (gzip, bzip2, lzma, xz, lz4, brotli, zstd). Это отключено по умолчанию.
* `-C/--context`: Показать строки, окружающие совпадение.
* `--sort path`: Заставить ripgrep сортировать свой вывод по имени файла. (Это отключает параллелизм, поэтому
  может быть медленнее.)
* `-L/--follow`: Обходить символьные ссылки при рекурсивном поиске.
* `-M/--max-columns`: Ограничить длину строк, напечатанных ripgrep.
* `--debug`: Показывает вывод отладки ripgrep. Это полезно для понимания того, почему определенный файл может
  быть игнорирован из поиска, или какие виды конфигурации ripgrep загружает из окружения.
