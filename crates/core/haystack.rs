/*!
Определяет построитель для стогов сена.

"Сток сена" представляет собой то, что мы хотим искать. Он инкапсулирует
логику того, следует ли искать стог сена или нет, отдельно от стандартных
правил игнорирования и другой логики фильтрации.

По существу, стог сена оборачивает запись каталога и добавляет вокруг нее
некоторую легкую логику уровня приложения.
*/

use std::path::Path;

/// Построитель для создания объектов для поиска.
#[derive(Clone, Debug)]
pub(crate) struct HaystackBuilder {
    strip_dot_prefix: bool,
}

impl HaystackBuilder {
    /// Вернуть новый построитель стогов сена с конфигурацией по умолчанию.
    pub(crate) fn new() -> HaystackBuilder {
        HaystackBuilder { strip_dot_prefix: false }
    }

    /// Создать новый стог сена из возможно отсутствующей записи каталога.
    ///
    /// Если запись каталога отсутствует, то соответствующая ошибка
    /// логируется, если сообщения настроены. В противном случае, если
    /// запись каталога считается доступной для поиска, то она возвращается
    /// как стог сена.
    pub(crate) fn build_from_result(
        &self,
        result: Result<ignore::DirEntry, ignore::Error>,
    ) -> Option<Haystack> {
        match result {
            Ok(dent) => self.build(dent),
            Err(err) => {
                err_message!("{err}");
                None
            }
        }
    }

    /// Создать новый стог сена, используя конфигурацию этого построителя.
    ///
    /// Если запись каталога не может быть создана или иначе не должна
    /// искаться, то возвращается `None` после вывода любых соответствующих
    /// сообщений журнала.
    fn build(&self, dent: ignore::DirEntry) -> Option<Haystack> {
        let hay = Haystack { dent, strip_dot_prefix: self.strip_dot_prefix };
        if let Some(err) = hay.dent.error() {
            ignore_message!("{err}");
        }
        // Если эта запись была явно предоставлена конечным пользователем,
        // то мы всегда хотим искать ее.
        if hay.is_explicit() {
            return Some(hay);
        }
        // На этом этапе мы хотим искать только то, что явно является файлом.
        // Это исключает символические ссылки. (Если ripgrep был настроен на
        // следование символическим ссылкам, то они уже были пройдены
        // обходом каталога.)
        if hay.is_file() {
            return Some(hay);
        }
        // У нас ничего нет. Выводим отладочное сообщение, но только если это
        // не каталог. В противном случае, вывод сообщений для каталогов
        // просто шумен.
        if !hay.is_dir() {
            log::debug!(
                "игнорирование {}: не удалось пройти фильтр стогов сена: \
                 тип файла: {:?}, метаданные: {:?}",
                hay.dent.path().display(),
                hay.dent.file_type(),
                hay.dent.metadata()
            );
        }
        None
    }

    /// Когда включено, если путь к файлу стога сена начинается с `./`, то
    /// он удаляется.
    ///
    /// Это полезно при неявном поиске в текущем рабочем каталоге.
    pub(crate) fn strip_dot_prefix(
        &mut self,
        yes: bool,
    ) -> &mut HaystackBuilder {
        self.strip_dot_prefix = yes;
        self
    }
}

/// Стог сена — это то, что мы хотим искать.
///
/// Обычно стог сена — это либо файл, либо stdin.
#[derive(Clone, Debug)]
pub(crate) struct Haystack {
    dent: ignore::DirEntry,
    strip_dot_prefix: bool,
}

impl Haystack {
    /// Вернуть путь к файлу, соответствующий этому стогу сена.
    ///
    /// Если этот стог сена соответствует stdin, то вместо этого возвращается
    /// специальный путь `<stdin>`.
    pub(crate) fn path(&self) -> &Path {
        if self.strip_dot_prefix && self.dent.path().starts_with("./") {
            self.dent.path().strip_prefix("./").unwrap()
        } else {
            self.dent.path()
        }
    }

    /// Возвращает true тогда и только тогда, когда эта запись соответствует
    /// stdin.
    pub(crate) fn is_stdin(&self) -> bool {
        self.dent.is_stdin()
    }

    /// Возвращает true тогда и только тогда, когда эта запись соответствует
    /// стогу сена для поиска, который был явно предоставлен конечным
    /// пользователем.
    ///
    /// Обычно это соответствует либо stdin, либо явному аргументу пути к
    /// файлу. Например, в `rg foo some-file ./some-dir/`, `some-file` является
    /// явным стогом сена, но, например, `./some-dir/some-other-file` — нет.
    ///
    /// Однако обратите внимание, что ripgrep не смотрит сквозь оболочечный
    /// глоббинг. Например, в `rg foo ./some-dir/*`,
    /// `./some-dir/some-other-file` будет рассматриваться как явный стог сена.
    pub(crate) fn is_explicit(&self) -> bool {
        // stdin очевиден. Когда запись имеет глубину 0, это означает, что
        // она была явно предоставлена нашему итератору каталога, что означает,
        // что она, в свою очередь, была явно предоставлена конечным
        // пользователем. Проверка !is_dir означает, что мы хотим искать файлы,
        // даже если их символические ссылки, опять же, потому что они были
        // явно предоставлены. (И мы никогда не хотим пытаться искать каталог.)
        self.is_stdin() || (self.dent.depth() == 0 && !self.is_dir())
    }

    /// Возвращает true тогда и только тогда, когда этот стог сена указывает
    /// на каталог после следования символическим ссылкам.
    fn is_dir(&self) -> bool {
        let ft = match self.dent.file_type() {
            None => return false,
            Some(ft) => ft,
        };
        if ft.is_dir() {
            return true;
        }
        // Если это символическая ссылка, то мы хотим следовать ей, чтобы
        // определить, является ли она каталогом или нет.
        self.dent.path_is_symlink() && self.dent.path().is_dir()
    }

    /// Возвращает true тогда и только тогда, когда этот стог сена указывает
    /// на файл.
    fn is_file(&self) -> bool {
        self.dent.file_type().map_or(false, |ft| ft.is_file())
    }
}
