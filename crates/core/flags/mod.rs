/*!
Определяет интерфейс командной строки ripgrep.

Этот модуль занимается всем, что связано с флагами и позиционными
аргументами ripgrep. Это включает генерацию автодополнений для оболочки,
вывод `--help` и даже страницу руководства man для ripgrep. Он также
отвечает за разбор и проверку каждого флага (включая чтение файла
конфигурации ripgrep) и управляет точками взаимодействия между этими
флагами и вспомогательными библиотеками ripgrep. Например, после того
как [`HiArgs`] был создан, он знает, как создать многопоточный рекурсивный
обходчик каталогов.
*/
use std::{
    ffi::OsString,
    fmt::Debug,
    panic::{RefUnwindSafe, UnwindSafe},
};

pub(crate) use crate::flags::{
    complete::{
        bash::generate as generate_complete_bash,
        fish::generate as generate_complete_fish,
        powershell::generate as generate_complete_powershell,
        zsh::generate as generate_complete_zsh,
    },
    doc::{
        help::{
            generate_long as generate_help_long,
            generate_short as generate_help_short,
        },
        man::generate as generate_man_page,
        version::{
            generate_long as generate_version_long,
            generate_pcre2 as generate_version_pcre2,
            generate_short as generate_version_short,
        },
    },
    hiargs::HiArgs,
    lowargs::{GenerateMode, Mode, SearchMode, SpecialMode},
    parse::{ParseResult, parse},
};

mod complete;
mod config;
mod defs;
mod doc;
mod hiargs;
mod lowargs;
mod parse;

/// Трейт, инкапсулирующий определение опционального флага для ripgrep.
///
/// Этот трейт предназначен для использования через динамическую диспетчеризацию.
/// А именно, модуль `defs` предоставляет единый глобальный срез значений
/// `&dyn Flag`, соответствующих всем флагам в ripgrep.
///
/// Требуемые позиционные аргументы ripgrep обрабатываются парсером и
/// преобразованием из низкоуровневых аргументов в высокоуровневые аргументы.
/// А именно, все позиционные аргументы ripgrep рассматриваются как пути к
/// файлам, за исключением определенных обстоятельств, когда первый аргумент
/// рассматривается как шаблон регулярного выражения.
///
/// Обратите внимание, что каждая реализация этого трейта требует длинного
/// имени флага, но также может иметь короткую версию и даже флаг отрицания.
/// Например, флаг `-E/--encoding` принимает значение, но также имеет флаг
/// отрицания `--no-encoding` для возврата к «автоматическому» определению
/// кодировки. Все три из `-E`, `--encoding` и `--no-encoding` предоставляются
/// одной реализацией этого трейта.
///
/// ripgrep поддерживает только флаги, которые являются переключателями или
/// флаги, которые принимают одно значение. Флаги, принимающие несколько
/// значений, являются неподдерживаемой аномалией.
trait Flag: Debug + Send + Sync + UnwindSafe + RefUnwindSafe + 'static {
    /// Возвращает true, если этот флаг является переключателем. Когда флаг
    /// является переключателем, парсер CLI не будет искать значение после
    /// того, как флаг будет увиден.
    fn is_switch(&self) -> bool;

    /// Короткое односимвольное имя для этого флага. По умолчанию возвращает
    /// `None`, что означает, что флаг не имеет короткого имени.
    ///
    /// Возвращаемый байт должен быть кодовой точкой ASCII, которая является
    /// `.` или буквенно-цифровым символом.
    fn name_short(&self) -> Option<u8> {
        None
    }

    /// Возвращает длинное имя этого флага. Все флаги должны иметь «длинное»
    /// имя.
    ///
    /// Длинное имя должно быть не менее 2 байт, и все его байты должны быть
    /// кодовыми точками ASCII, которые являются либо `-`, либо буквенно-цифровыми.
    fn name_long(&self) -> &'static str;

    /// Возвращает список псевдонимов для этого флага.
    ///
    /// Псевдонимы должны следовать тем же правилам, что и `Flag::name_long`.
    ///
    /// По умолчанию возвращается пустой срез.
    fn aliases(&self) -> &'static [&'static str] {
        &[]
    }

    /// Возвращает отрицательное имя для этого флага. Отрицание флага
    /// предназначено для того, чтобы иметь противоположное значение флага
    /// или иным образом «выключать» что-то или возвращать его к поведению
    /// по умолчанию.
    ///
    /// Отрицательные флаги не перечислены в собственном разделе в выводе
    /// `-h/--help` или на странице руководства man. Вместо этого они
    /// автоматически упоминаются в конце раздела документации флага, который
    /// они отрицают.
    ///
    /// Псевдонимы должны следовать тем же правилам, что и `Flag::name_long`.
    ///
    /// По умолчанию флаг не имеет отрицания, и это возвращает `None`.
    fn name_negated(&self) -> Option<&'static str> {
        None
    }

    /// Возвращает имя переменной, описывающее тип значения, которое принимает
    /// этот флаг. Это всегда должно быть установлено для флагов, не являющихся
    /// переключателями, и никогда не устанавливается для флагов-переключателей.
    ///
    /// Например, флаг `--max-count` имеет имя переменной, установленное в `NUM`.
    ///
    /// Соглашение заключается в использовании заглавных букв для имен переменных.
    ///
    /// По умолчанию это возвращает `None`.
    fn doc_variable(&self) -> Option<&'static str> {
        None
    }

    /// Возвращает категорию этого флага.
    ///
    /// Каждый флаг должен иметь одну категорию. Категории используются для
    /// организации флагов в сгенерированной документации.
    fn doc_category(&self) -> Category;

    /// (Очень) короткая строка документации, описывающая, что делает этот флаг.
    ///
    /// Это может жертвовать «правильным английским», чтобы быть как можно
    /// более кратким. Как правило, мы стараемся обеспечить, чтобы `rg -h`
    /// не имел строк, превышающих 79 столбцов.
    fn doc_short(&self) -> &'static str;

    /// (Возможно, очень) длинная строка документации, подробно описывающая,
    /// что делает этот флаг. Это должно быть в формате mandoc/mdoc.
    fn doc_long(&self) -> &'static str;

    /// Если это не переключатель, который принимает небольшой набор конкретных
    /// значений, то это должно перечислять их.
    ///
    /// По умолчанию это возвращает пустой срез.
    fn doc_choices(&self) -> &'static [&'static str] {
        &[]
    }

    fn completion_type(&self) -> CompletionType {
        CompletionType::Other
    }

    /// Учитывая разобранное значение (которое может быть просто переключателем),
    /// это должно обновить состояние в `args` на основе значения, данного для
    /// этого флага.
    ///
    /// Это может обновить состояние для других флагов по мере необходимости.
    ///
    /// Флаги `-V/--version` и `-h/--help` обрабатываются особо в парсере и
    /// не должны делать ничего здесь.
    ///
    /// По соглашению, реализации обычно не должны пытаться «делать» что-либо,
    /// кроме как проверять данное значение. Например, реализация для
    /// `--hostname-bin` не должна пытаться разрешить имя хоста для
    /// использования, запуская предоставленный бинарный файл. Это должно быть
    /// сохранено для более позднего шага. Это соглашение используется для
    /// обеспечения того, чтобы получение низкоуровневых аргументов было
    /// максимально надежным и быстрым. Это также гарантирует, что «выполнение
    /// чего-либо» происходит минимальное количество раз. Например, избегая
    /// попытки найти имя хоста здесь, мы можем сделать это один раз позже,
    /// независимо от того, сколько раз предоставлен `--hostname-bin`.
    ///
    /// Реализации не должны включать имя флага в сообщение об ошибке,
    /// которое возвращается. Имя флага включается автоматически парсером.
    fn update(
        &self,
        value: FlagValue,
        args: &mut crate::flags::lowargs::LowArgs,
    ) -> anyhow::Result<()>;
}

/// Категория, к которой принадлежит флаг.
///
/// Категории используются для организации флагов в «логические» группы в
/// сгенерированной документации.
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]
enum Category {
    /// Флаги, связанные с тем, как ripgrep читает свои входные данные. Его
    /// «входные данные» обычно состоят из шаблонов, которые он пытается
    /// сопоставить, и стогов сена, которые он пытается искать.
    Input,
    /// Флаги, связанные с работой самого поиска. Например, включено ли
    /// сопоставление без учета регистра.
    Search,
    /// Флаги, связанные с тем, как ripgrep фильтрует стога сена. Например,
    /// следует ли уважать файлы gitignore или нет.
    Filter,
    /// Флаги, связанные с тем, как ripgrep показывает свои результаты поиска.
    /// Например, показывать ли номера строк или нет.
    Output,
    /// Флаги, связанные с изменением вывода ripgrep на более фундаментальном
    /// уровне. Например, флаги вроде `--count` подавляют печать отдельных
    /// строк и вместо этого печатают общее количество совпадений для каждого
    /// искомого файла.
    OutputModes,
    /// Флаги, связанные с поведением ведения журнала, например, выводом
    /// несмертельных сообщений об ошибках или печатью статистики поиска.
    Logging,
    /// Другое поведение, не связанное с основной функциональностью ripgrep.
    /// Например, печать правил глоббинга по типу файлов или печать списка
    /// файлов, которые ripgrep будет искать, без фактического их поиска.
    OtherBehaviors,
}

impl Category {
    /// Возвращает строковое представление этой категории.
    ///
    /// Эта строка является именем переменной, используемой в различных
    /// шаблонах для сгенерированной документации. Это имя может быть
    /// использовано для интерполяции.
    fn as_str(&self) -> &'static str {
        match *self {
            Category::Input => "input",
            Category::Search => "search",
            Category::Filter => "filter",
            Category::Output => "output",
            Category::OutputModes => "output-modes",
            Category::Logging => "logging",
            Category::OtherBehaviors => "other-behaviors",
        }
    }
}

/// Вид аргумента, который принимает флаг, для использования в автодополнении оболочки.
#[derive(Clone, Copy, Debug)]
enum CompletionType {
    /// Никакой специальной категории. is_switch() и doc_choices() могут применяться.
    Other,
    /// Путь к файлу.
    Filename,
    /// Команда в $PATH.
    Executable,
    /// Имя типа файла, как используется, например, в --type.
    Filetype,
    /// Имя кодировки encoding_rs, как используется в --encoding.
    Encoding,
}

/// Представляет значение, разобранное из командной строки.
///
/// Это не включает соответствующий флаг, но значения бывают одной из
/// двух форм: переключатель (включен или выключен) или произвольное значение.
///
/// Обратите внимание, что CLI напрямую не поддерживает отрицательные
/// переключатели. Например, вы не можете сделать что-то вроде `-n=false`
/// или любой подобной чепухи. Вместо этого парсер CLI знает о том, какие
/// имена флагов являются отрицаниями, а какие нет (благодаря трейту `Flag`).
/// Если флаг, который дан, известен как отрицание, то значение
/// `FlagValue::Switch(false)` передается в `Flag::update`.
#[derive(Debug)]
enum FlagValue {
    /// Флаг, который либо включен, либо выключен.
    Switch(bool),
    /// Флаг, который содержит произвольное пользовательское значение.
    Value(OsString),
}

impl FlagValue {
    /// Возвращает значение да/нет этого переключателя.
    ///
    /// Если это значение флага не является переключателем, то это паникует.
    ///
    /// Это полезно при написании реализации `Flag::update`. А именно,
    /// вызывающие обычно знают, ожидается ли переключатель или значение.
    /// Если флаг — это что-то другое, то это указывает на ошибку, и поэтому
    /// паника допустима.
    fn unwrap_switch(self) -> bool {
        match self {
            FlagValue::Switch(yes) => yes,
            FlagValue::Value(_) => {
                unreachable!("получено значение флага, но ожидался переключатель")
            }
        }
    }

    /// Возвращает предоставленное пользователем значение этого флага.
    ///
    /// Если этот флаг является переключателем, то это паникует.
    ///
    /// Это полезно при написании реализации `Flag::update`. А именно,
    /// вызывающие обычно знают, ожидается ли переключатель или значение.
    /// Если флаг — это что-то другое, то это указывает на ошибку, и поэтому
    /// паника допустима.
    fn unwrap_value(self) -> OsString {
        match self {
            FlagValue::Switch(_) => {
                unreachable!("получен переключатель, но ожидалось значение флага")
            }
            FlagValue::Value(v) => v,
        }
    }
}
