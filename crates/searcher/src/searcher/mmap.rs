use std::{fs::File, path::Path};

use memmap::Mmap;

/// Управляет стратегией определения, когда использовать отображения в память.
///
/// Если поисковик вызывается в обстоятельствах, где возможно использовать
/// отображения в память, и отображения в память включены, то он попытается
/// сделать это, если считает, что это ускорит поиск.
///
/// По умолчанию отображения в память отключены.
#[derive(Clone, Debug)]
pub struct MmapChoice(MmapChoiceImpl);

#[derive(Clone, Debug)]
enum MmapChoiceImpl {
    Auto,
    Never,
}

impl Default for MmapChoice {
    fn default() -> MmapChoice {
        MmapChoice(MmapChoiceImpl::Never)
    }
}

impl MmapChoice {
    /// Использовать отображения в память, когда они считаются полезными.
    ///
    /// Эвристики, используемые для определения, использовать ли отображение
    /// в память или нет, могут зависеть от многих вещей, включая, но не
    /// ограничиваясь размером файла и платформой.
    ///
    /// Если отображения в память недоступны или не могут быть использованы
    /// для определённых входных данных, то вместо этого используются
    /// обычные вызовы чтения ОС.
    ///
    /// # Безопасность
    ///
    /// Этот конструктор не безопасен, потому что нет очевидного способа
    /// инкапсулировать безопасность отображений файлов в память на всех
    /// платформах без одновременного отрицания некоторых или всех их
    /// преимуществ.
    ///
    /// Контракт, который вызывающая сторона должна соблюдать, не является
    /// точным, но в основном сводится к чему-то вроде: «вызывающая сторона
    /// гарантирует, что основной файл не будет изменён». Это, конечно,
    /// невозможно во многих средах. Однако инструменты командной строки
    /// могут всё же решить пойти на риск, скажем, возникновения `SIGBUS`
    /// при попытке прочитать отображение в память.
    pub unsafe fn auto() -> MmapChoice {
        MmapChoice(MmapChoiceImpl::Auto)
    }

    /// Никогда не использовать отображения в память, независимо от
    /// обстоятельств. Это значение по умолчанию.
    pub fn never() -> MmapChoice {
        MmapChoice(MmapChoiceImpl::Never)
    }

    /// Вернуть отображение в память, если отображения в память включены и
    /// если создание отображения из данного файла удалось и если считается,
    /// что отображения в память полезны для производительности.
    ///
    /// Если это пытается открыть отображение в память и это не удаётся,
    /// то возвращается `None`, а соответствующая ошибка (вместе с путём
    /// к файлу, если он присутствует) логируется на уровне отладки.
    pub(crate) fn open(
        &self,
        file: &File,
        path: Option<&Path>,
    ) -> Option<Mmap> {
        if !self.is_enabled() {
            return None;
        }
        if cfg!(target_os = "macos") {
            // Я полагаю, отображения в память на macOS не очень хороши.
            // Следует переоценить.
            return None;
        }
        // БЕЗОПАСНОСТЬ: Это приемлемо, потому что единственный способ,
        // которым `MmapChoiceImpl` может быть `Auto`, — это если
        // вызывающая сторона вызвала конструктор `auto`, который сам
        // по себе не безопасен. Таким образом, это распространение
        // утверждения вызывающей стороны о том, что использование
        // отображений в память безопасно.
        match unsafe { Mmap::map(file) } {
            Ok(mmap) => Some(mmap),
            Err(err) => {
                if let Some(path) = path {
                    log::debug!(
                        "{}: не удалось открыть отображение в память: {}",
                        path.display(),
                        err
                    );
                } else {
                    log::debug!("не удалось открыть отображение в память: {}", err);
                }
                None
            }
        }
    }

    /// Может ли эта стратегия использовать отображения в память или нет.
    pub(crate) fn is_enabled(&self) -> bool {
        match self.0 {
            MmapChoiceImpl::Auto => true,
            MmapChoiceImpl::Never => false,
        }
    }
}
