use std::io;

use grep_matcher::LineTerminator;

use crate::{
    lines::LineIter,
    searcher::{ConfigError, Searcher},
};

/// Трейт, который описывает ошибки, которые могут сообщаться поисковиками и
/// реализациями `Sink`.
///
/// Если у вас нет специализированного варианта использования, вам, вероятно, не нужно
/// реализовывать этот трейт явно. Скорее всего, использование `std::io::Error`
/// (который реализует этот трейт) для вашего типа ошибки достаточно,
/// в значительной степени потому, что большинство ошибок, возникающих во время поиска, вероятно, будут
/// `std::io::Error`.
pub trait SinkError: Sized {
    /// Конструктор для преобразования любого значения, удовлетворяющего
    /// трейту `std::fmt::Display`, в ошибку.
    fn error_message<T: std::fmt::Display>(message: T) -> Self;

    /// Конструктор для преобразования ошибок ввода/вывода, возникающих при поиске, в
    /// ошибку этого типа.
    ///
    /// По умолчанию это реализовано через конструктор `error_message`.
    fn error_io(err: io::Error) -> Self {
        Self::error_message(err)
    }

    /// Конструктор для преобразования ошибок конфигурации, возникающих при
    /// создании поисковика, в ошибку этого типа.
    ///
    /// По умолчанию это реализовано через конструктор `error_message`.
    fn error_config(err: ConfigError) -> Self {
        Self::error_message(err)
    }
}

/// `std::io::Error` может использоваться как ошибка для реализаций `Sink`
/// из коробки.
impl SinkError for io::Error {
    fn error_message<T: std::fmt::Display>(message: T) -> io::Error {
        io::Error::new(io::ErrorKind::Other, message.to_string())
    }

    fn error_io(err: io::Error) -> io::Error {
        err
    }
}

/// `Box<dyn std::error::Error>` может использоваться как ошибка для реализаций `Sink`
/// из коробки.
impl SinkError for Box<dyn std::error::Error> {
    fn error_message<T: std::fmt::Display>(
        message: T,
    ) -> Box<dyn std::error::Error> {
        Box::<dyn std::error::Error>::from(message.to_string())
    }
}

/// Трейт, который определяет, как результаты от поисковиков обрабатываются.
///
/// В этом крейте поисковик следует модели "push". Что это означает:
/// поисковик управляет выполнением и передаёт результаты обратно вызывающему. Это
/// в отличие от модели "pull", где вызывающий управляет выполнением и
/// берёт результаты по мере необходимости. Это также известно как стратегии итерации
/// "внутренняя" и "внешняя" соответственно.
///
/// По разным причинам, включая сложность реализации поисковика,
/// этот крейт выбрал модель выполнения "push" или "внутреннюю". Таким образом, чтобы
/// действовать с результатами поиска, вызывающие должны предоставить реализацию
/// этого трейта поисковику, и затем поисковик отвечает за вызов методов
/// этого трейта.
///
/// Этот трейт определяет несколько поведений:
///
/// * Что делать при нахождении совпадения. Вызывающие должны предоставить это.
/// * Что делать при возникновении ошибки. Вызывающие должны предоставить это через
///   трейт [`SinkError`]. Обычно вызывающие могут просто использовать `std::io::Error` для
///   этого, который уже реализует `SinkError`.
/// * Что делать при нахождении контекстной строки. По умолчанию они
///   игнорируются.
/// * Что делать при нахождении разрыва между контекстными строками. По
///   умолчанию это игнорируется.
/// * Что делать при начале поиска. По умолчанию это ничего не делает.
/// * Что делать при успешном завершении поиска. По умолчанию это ничего не делает.
///
/// Вызывающие должны как минимум указать поведение при возникновении ошибки и
/// поведение при нахождении совпадения. Остальное необязательно. Для каждого поведения
/// вызывающие могут сообщить об ошибке (например, если запись результата в другое
/// место не удалась) или просто вернуть `false`, если они хотят остановить поиск
/// (например, при реализации ограничения на количество отображаемых результатов поиска).
///
/// При сообщении об ошибках (будь то в поисковике или в реализации
/// `Sink`), поисковики немедленно прекращают работу, не вызывая `finish`.
///
/// Для более простого использования `Sink` вызывающие могут выбрать использование одной из
/// более удобных, но менее гибких реализаций в модуле
/// [`sinks`].
pub trait Sink {
    /// Тип ошибки, которая должна сообщаться поисковиком.
    ///
    /// Ошибки этого типа не только возвращаются методами этого
    /// трейта, но конструкторы, определённые в `SinkError`, также используются в
    /// самой реализации поисковика. Например, когда происходит ошибка ввода/вывода при
    /// чтении данных из файла.
    type Error: SinkError;

    /// Этот метод вызывается всякий раз, когда находится совпадение.
    ///
    /// Если многострочный режим включён в поисковике, то сообщаемое здесь совпадение
    /// может охватывать несколько строк и может включать несколько совпадений. Когда многострочный
    /// режим отключён, то совпадение гарантированно охватывает ровно одну
    /// непустую строку (где одна строка — это как минимум терминатор строки).
    ///
    /// Если это возвращает `true`, то поиск продолжается. Если это возвращает
    /// `false`, то поиск немедленно останавливается и вызывается `finish`.
    ///
    /// Если это возвращает ошибку, то поиск немедленно останавливается,
    /// `finish` не вызывается, и ошибка передаётся обратно вызывающему
    /// поисковика.
    fn matched(
        &mut self,
        _searcher: &Searcher,
        _mat: &SinkMatch<'_>,
    ) -> Result<bool, Self::Error>;

    /// Этот метод вызывается всякий раз, когда находится контекстная строка, и является
    /// необязательным для реализации. По умолчанию он ничего не делает и возвращает `true`.
    ///
    /// Во всех случаях гарантируется, что контекст охватывает ровно одну
    /// непустую строку (где одна строка — это как минимум терминатор строки).
    ///
    /// Если это возвращает `true`, то поиск продолжается. Если это возвращает
    /// `false`, то поиск немедленно останавливается и вызывается `finish`.
    ///
    /// Если это возвращает ошибку, то поиск немедленно останавливается,
    /// `finish` не вызывается, и ошибка передаётся обратно вызывающему
    /// поисковика.
    #[inline]
    fn context(
        &mut self,
        _searcher: &Searcher,
        _context: &SinkContext<'_>,
    ) -> Result<bool, Self::Error> {
        Ok(true)
    }

    /// Этот метод вызывается всякий раз, когда находится разрыв в контекстных строках,
    /// и является необязательным для реализации. По умолчанию он ничего не делает и возвращает
    /// `true`.
    ///
    /// Разрыв может возникнуть только тогда, когда включена отчётность о контексте (то есть
    /// когда `before_context` или `after_context` больше
    /// `0`). Точнее, разрыв возникает между не смежными группами
    /// строк.
    ///
    /// Если это возвращает `true`, то поиск продолжается. Если это возвращает
    /// `false`, то поиск немедленно останавливается и вызывается `finish`.
    ///
    /// Если это возвращает ошибку, то поиск немедленно останавливается,
    /// `finish` не вызывается, и ошибка передаётся обратно вызывающему
    /// поисковика.
    #[inline]
    fn context_break(
        &mut self,
        _searcher: &Searcher,
    ) -> Result<bool, Self::Error> {
        Ok(true)
    }

    /// Этот метод вызывается всякий раз, когда включено обнаружение двоичных данных и найдены
    /// двоичные данные. Если двоичные данные найдены, то это вызывается как минимум
    /// один раз для первого вхождения с абсолютным смещением байта, при котором
    /// начинаются двоичные данные.
    ///
    /// Если это возвращает `true`, то поиск продолжается. Если это возвращает
    /// `false`, то поиск немедленно останавливается и вызывается `finish`.
    ///
    /// Если это возвращает ошибку, то поиск немедленно останавливается,
    /// `finish` не вызывается, и ошибка передаётся обратно вызывающему
    /// поисковика.
    ///
    /// По умолчанию он ничего не делает и возвращает `true`.
    #[inline]
    fn binary_data(
        &mut self,
        _searcher: &Searcher,
        _binary_byte_offset: u64,
    ) -> Result<bool, Self::Error> {
        Ok(true)
    }

    /// Этот метод вызывается, когда поиск начался, до выполнения какого-либо поиска.
    /// По умолчанию это ничего не делает.
    ///
    /// Если это возвращает `true`, то поиск продолжается. Если это возвращает
    /// `false`, то поиск немедленно останавливается и вызывается `finish`.
    ///
    /// Если это возвращает ошибку, то поиск немедленно останавливается,
    /// `finish` не вызывается, и ошибка передаётся обратно вызывающему
    /// поисковика.
    #[inline]
    fn begin(&mut self, _searcher: &Searcher) -> Result<bool, Self::Error> {
        Ok(true)
    }

    /// Этот метод вызывается, когда поиск завершён. По умолчанию это
    /// ничего не делает.
    ///
    /// Если это возвращает ошибку, ошибка передаётся обратно вызывающему
    /// поисковика.
    #[inline]
    fn finish(
        &mut self,
        _searcher: &Searcher,
        _: &SinkFinish,
    ) -> Result<(), Self::Error> {
        Ok(())
    }
}

impl<'a, S: Sink> Sink for &'a mut S {
    type Error = S::Error;

    #[inline]
    fn matched(
        &mut self,
        searcher: &Searcher,
        mat: &SinkMatch<'_>,
    ) -> Result<bool, S::Error> {
        (**self).matched(searcher, mat)
    }

    #[inline]
    fn context(
        &mut self,
        searcher: &Searcher,
        context: &SinkContext<'_>,
    ) -> Result<bool, S::Error> {
        (**self).context(searcher, context)
    }

    #[inline]
    fn context_break(
        &mut self,
        searcher: &Searcher,
    ) -> Result<bool, S::Error> {
        (**self).context_break(searcher)
    }

    #[inline]
    fn binary_data(
        &mut self,
        searcher: &Searcher,
        binary_byte_offset: u64,
    ) -> Result<bool, S::Error> {
        (**self).binary_data(searcher, binary_byte_offset)
    }

    #[inline]
    fn begin(&mut self, searcher: &Searcher) -> Result<bool, S::Error> {
        (**self).begin(searcher)
    }

    #[inline]
    fn finish(
        &mut self,
        searcher: &Searcher,
        sink_finish: &SinkFinish,
    ) -> Result<(), S::Error> {
        (**self).finish(searcher, sink_finish)
    }
}

impl<S: Sink + ?Sized> Sink for Box<S> {
    type Error = S::Error;

    #[inline]
    fn matched(
        &mut self,
        searcher: &Searcher,
        mat: &SinkMatch<'_>,
    ) -> Result<bool, S::Error> {
        (**self).matched(searcher, mat)
    }

    #[inline]
    fn context(
        &mut self,
        searcher: &Searcher,
        context: &SinkContext<'_>,
    ) -> Result<bool, S::Error> {
        (**self).context(searcher, context)
    }

    #[inline]
    fn context_break(
        &mut self,
        searcher: &Searcher,
    ) -> Result<bool, S::Error> {
        (**self).context_break(searcher)
    }

    #[inline]
    fn binary_data(
        &mut self,
        searcher: &Searcher,
        binary_byte_offset: u64,
    ) -> Result<bool, S::Error> {
        (**self).binary_data(searcher, binary_byte_offset)
    }

    #[inline]
    fn begin(&mut self, searcher: &Searcher) -> Result<bool, S::Error> {
        (**self).begin(searcher)
    }

    #[inline]
    fn finish(
        &mut self,
        searcher: &Searcher,
        sink_finish: &SinkFinish,
    ) -> Result<(), S::Error> {
        (**self).finish(searcher, sink_finish)
    }
}

/// Сводные данные, сообщаемые в конце поиска.
///
/// Это сообщает такие данные, как общее количество найденных байтов и
/// абсолютное смещение первого вхождения двоичных данных, если таковые были найдены.
///
/// Поисковик, который останавливается досрочно из-за ошибки, не вызывает `finish`.
/// Поисковик, который останавливается досрочно, потому что реализация `Sink` указала ему
/// сделать это, всё равно вызовет `finish`.
#[derive(Clone, Debug)]
pub struct SinkFinish {
    pub(crate) byte_count: u64,
    pub(crate) binary_byte_offset: Option<u64>,
}

impl SinkFinish {
    /// Вернуть общее количество найденных байтов.
    #[inline]
    pub fn byte_count(&self) -> u64 {
        self.byte_count
    }

    /// Если обнаружение двоичных данных включено и двоичные данные были найдены, то это
    /// возвращает абсолютное смещение байта первого обнаруженного байта двоичных
    /// данных.
    ///
    /// Обратите внимание, что поскольку это абсолютное смещение байта, на него нельзя полагаться
    /// для индексации в любую адресуемую память.
    #[inline]
    pub fn binary_byte_offset(&self) -> Option<u64> {
        self.binary_byte_offset
    }
}

/// Тип, который описывает совпадение, сообщаемое поисковиком.
#[derive(Clone, Debug)]
pub struct SinkMatch<'b> {
    pub(crate) line_term: LineTerminator,
    pub(crate) bytes: &'b [u8],
    pub(crate) absolute_byte_offset: u64,
    pub(crate) line_number: Option<u64>,
    pub(crate) buffer: &'b [u8],
    pub(crate) bytes_range_in_buffer: std::ops::Range<usize>,
}

impl<'b> SinkMatch<'b> {
    /// Возвращает байты для всех совпадающих строк, включая терминаторы строк,
    /// если они существуют.
    #[inline]
    pub fn bytes(&self) -> &'b [u8] {
        self.bytes
    }

    /// Вернуть итератор по строкам в этом совпадении.
    ///
    /// Если включён многострочный поиск, то это может выдать более одной
    /// строки (но всегда как минимум одну строку). Если многострочный поиск отключён,
    /// то это всегда сообщает ровно одну строку (но может состоять только из
    /// терминатора строки).
    ///
    /// Строки, выдаваемые этим итератором, включают свои терминаторы.
    #[inline]
    pub fn lines(&self) -> LineIter<'b> {
        LineIter::new(self.line_term.as_byte(), self.bytes)
    }

    /// Возвращает абсолютное смещение байта начала этого совпадения. Это
    /// смещение является абсолютным в том смысле, что оно относительно самого начала
    /// входных данных в поиске и никогда не может считаться допустимым индексом
    /// в срезе в памяти.
    #[inline]
    pub fn absolute_byte_offset(&self) -> u64 {
        self.absolute_byte_offset
    }

    /// Возвращает номер строки первой строки в этом совпадении, если доступно.
    ///
    /// Номера строк доступны только тогда, когда билдеру поиска дано указание
    /// вычислять их.
    #[inline]
    pub fn line_number(&self) -> Option<u64> {
        self.line_number
    }

    /// Предоставляет как можно больше нижележащего буфера, который был найден.
    #[inline]
    pub fn buffer(&self) -> &'b [u8] {
        self.buffer
    }

    /// Возвращает диапазон, который соответствует тому, где [`SinkMatch::bytes`] появляется
    /// в [`SinkMatch::buffer`].
    #[inline]
    pub fn bytes_range_in_buffer(&self) -> std::ops::Range<usize> {
        self.bytes_range_in_buffer.clone()
    }
}

/// Тип контекста, сообщаемого поисковиком.
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum SinkContextKind {
    /// Сообщаемая строка находилась перед совпадением.
    Before,
    /// Сообщаемая строка находилась после совпадения.
    After,
    /// Любой другой тип сообщаемого контекста, например, в результате режима
    /// "passthru" поисковика.
    Other,
}

/// Тип, который описывает контекстную строку, сообщаемую поисковиком.
#[derive(Clone, Debug)]
pub struct SinkContext<'b> {
    #[cfg(test)]
    pub(crate) line_term: LineTerminator,
    pub(crate) bytes: &'b [u8],
    pub(crate) kind: SinkContextKind,
    pub(crate) absolute_byte_offset: u64,
    pub(crate) line_number: Option<u64>,
}

impl<'b> SinkContext<'b> {
    /// Возвращает байты контекста, включая терминаторы строк.
    #[inline]
    pub fn bytes(&self) -> &'b [u8] {
        self.bytes
    }

    /// Возвращает тип контекста.
    #[inline]
    pub fn kind(&self) -> &SinkContextKind {
        &self.kind
    }

    /// Вернуть итератор по строкам в этом совпадении.
    ///
    /// Это всегда выдаёт ровно одну строку (и эта одна строка может содержать только
    /// терминатор строки).
    ///
    /// Строки, выдаваемые этим итератором, включают свои терминаторы.
    #[cfg(test)]
    pub(crate) fn lines(&self) -> LineIter<'b> {
        LineIter::new(self.line_term.as_byte(), self.bytes)
    }

    /// Возвращает абсолютное смещение байта начала этого контекста. Это
    /// смещение является абсолютным в том смысле, что оно относительно самого начала
    /// входных данных в поиске и никогда не может считаться допустимым индексом
    /// в срезе в памяти.
    #[inline]
    pub fn absolute_byte_offset(&self) -> u64 {
        self.absolute_byte_offset
    }

    /// Возвращает номер строки первой строки в этом контексте, если
    /// доступно.
    ///
    /// Номера строк доступны только тогда, когда билдеру поиска дано указание
    /// вычислять их.
    #[inline]
    pub fn line_number(&self) -> Option<u64> {
        self.line_number
    }
}

/// Набор удобных реализаций `Sink`.
///
/// Каждая реализация в этом модуле чем-то жертвует ради
/// упрощения использования распространённых случаев. Чаще всего каждый тип является
/// обёрткой вокруг замыкания, указанного вызывающим, которое предоставляет ограниченный
/// доступ ко всему набору информации, доступной реализациям
/// `Sink`.
///
/// Например, `UTF8` sink приносит следующие жертвы:
///
/// * Все совпадения должны быть UTF-8. Произвольный `Sink` не имеет этого
///   ограничения и может работать с произвольными данными. Если этот sink видит невалидный
///   UTF-8, то возвращается ошибка, и поиск останавливается. (Используйте `Lossy`
///   sink вместо этого, чтобы подавить эту ошибку.)
/// * Поисковик должен быть настроен на отчётность о номерах строк. Если это не так,
///   то при первом совпадении сообщается об ошибке, и поиск останавливается.
/// * Контекстные строки, разрывы контекста и сводные данные, сообщаемые в конце
///   поиска, все игнорируются.
/// * Реализующие вынуждены использовать `std::io::Error` в качестве своего типа ошибки.
///
/// Если вам нужно больше гибкости, то рекомендуется реализовать трейт `Sink`
/// напрямую.
pub mod sinks {
    use std::io;

    use crate::searcher::Searcher;

    use super::{Sink, SinkError, SinkMatch};

    /// Sink, который предоставляет номера строк и совпадения как строки, игнорируя
    /// всё остальное.
    ///
    /// Эта реализация вернёт ошибку, если совпадение содержит невалидный
    /// UTF-8 или если поисковик не был настроен на подсчёт строк. Ошибки
    /// на невалидный UTF-8 можно подавить, используя `Lossy` sink вместо
    /// этого.
    ///
    /// Замыкание принимает два параметра: номер строки и UTF-8 строку,
    /// содержащую совпавшие данные. Замыкание возвращает
    /// `Result<bool, std::io::Error>`. Если `bool` равен `false`, то
    /// поиск немедленно останавливается. В противном случае поиск продолжается.
    ///
    /// Если многострочный режим был включён, номер строки относится к номеру
    /// первой строки в совпадении.
    #[derive(Clone, Debug)]
    pub struct UTF8<F>(pub F)
    where
        F: FnMut(u64, &str) -> Result<bool, io::Error>;

    impl<F> Sink for UTF8<F>
    where
        F: FnMut(u64, &str) -> Result<bool, io::Error>,
    {
        type Error = io::Error;

        fn matched(
            &mut self,
            _searcher: &Searcher,
            mat: &SinkMatch<'_>,
        ) -> Result<bool, io::Error> {
            let matched = match std::str::from_utf8(mat.bytes()) {
                Ok(matched) => matched,
                Err(err) => return Err(io::Error::error_message(err)),
            };
            let line_number = match mat.line_number() {
                Some(line_number) => line_number,
                None => {
                    let msg = "номера строк не включены";
                    return Err(io::Error::error_message(msg));
                }
            };
            (self.0)(line_number, &matched)
        }
    }

    /// Sink, который предоставляет номера строк и совпадения как (конвертированные с потерями)
    /// строки, игнорируя всё остальное.
    ///
    /// Это как `UTF8`, за исключением того, что если совпадение содержит невалидный UTF-8,
    /// то он будет конвертирован с потерями в валидный UTF-8 путём замены
    /// невалидного UTF-8 на символы замены Unicode.
    ///
    /// Эта реализация вернёт ошибку при первом совпадении, если
    /// поисковик не был настроен на подсчёт строк.
    ///
    /// Замыкание принимает два параметра: номер строки и UTF-8 строку,
    /// содержащую совпавшие данные. Замыкание возвращает
    /// `Result<bool, std::io::Error>`. Если `bool` равен `false`, то
    /// поиск немедленно останавливается. В противном случае поиск продолжается.
    ///
    /// Если многострочный режим был включён, номер строки относится к номеру
    /// первой строки в совпадении.
    #[derive(Clone, Debug)]
    pub struct Lossy<F>(pub F)
    where
        F: FnMut(u64, &str) -> Result<bool, io::Error>;

    impl<F> Sink for Lossy<F>
    where
        F: FnMut(u64, &str) -> Result<bool, io::Error>,
    {
        type Error = io::Error;

        fn matched(
            &mut self,
            _searcher: &Searcher,
            mat: &SinkMatch<'_>,
        ) -> Result<bool, io::Error> {
            use std::borrow::Cow;

            let matched = match std::str::from_utf8(mat.bytes()) {
                Ok(matched) => Cow::Borrowed(matched),
                // TODO: В теории должно быть возможно амортизировать
                // выделение здесь, но `std` не предоставляет такой API.
                // В любом случае это происходит только с совпадениями с невалидным UTF-8,
                // что должно быть довольно редко.
                Err(_) => String::from_utf8_lossy(mat.bytes()),
            };
            let line_number = match mat.line_number() {
                Some(line_number) => line_number,
                None => {
                    let msg = "номера строк не включены";
                    return Err(io::Error::error_message(msg));
                }
            };
            (self.0)(line_number, &matched)
        }
    }

    /// Sink, который предоставляет номера строк и совпадения как сырые байты,
    /// игнорируя всё остальное.
    ///
    /// Эта реализация вернёт ошибку при первом совпадении, если
    /// поисковик не был настроен на подсчёт строк.
    ///
    /// Замыкание принимает два параметра: номер строки и строку сырых байтов,
    /// содержащую совпавшие данные. Замыкание возвращает
    /// `Result<bool, std::io::Error>`. Если `bool` равен `false`, то
    /// поиск немедленно останавливается. В противном случае поиск продолжается.
    ///
    /// Если многострочный режим был включён, номер строки относится к номеру
    /// первой строки в совпадении.
    #[derive(Clone, Debug)]
    pub struct Bytes<F>(pub F)
    where
        F: FnMut(u64, &[u8]) -> Result<bool, io::Error>;

    impl<F> Sink for Bytes<F>
    where
        F: FnMut(u64, &[u8]) -> Result<bool, io::Error>,
    {
        type Error = io::Error;

        fn matched(
            &mut self,
            _searcher: &Searcher,
            mat: &SinkMatch<'_>,
        ) -> Result<bool, io::Error> {
            let line_number = match mat.line_number() {
                Some(line_number) => line_number,
                None => {
                    let msg = "номера строк не включены";
                    return Err(io::Error::error_message(msg));
                }
            };
            (self.0)(line_number, mat.bytes())
        }
    }
}
